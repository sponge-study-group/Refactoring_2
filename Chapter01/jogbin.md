# 제 1장 리팩터링 : 첫번째 예시

# 1.2 예시 프로그램을 본 소감

<aside>
💡 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.

</aside>

1. 오래 사용할 프로그램이라면 중복 코드는 골칫거리가 된다.
2. 리팩터링이 필요한 이유는 바로 프로그램의 수정사항 때문이다.
3. 다른 사람이 읽고 로직 파악하기 어렵다면 대책이 필요하다.

# 1.3 리팩터링의 첫 단계

<aside>
💡 리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.

</aside>

1. 리팩터링의 첫 단계는 항상 똑같다. 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드들 부터 마련해야 한다.
2. 이러한 테스트 코드는 성공/실패를 스스로 판단하는 자가진단 테스트로 만든다.

# 1.4 statement() 함수 쪼개기

<aside>
💡 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.

</aside>

1. 긴 함수를 리팩터링할 때는 먼저 전체 동작을 각각의 부분으로 나눌 수 있는 지점을 찾는다.
2. 지점에서 추출한 함수에는 그 코드가 하는 일을 실행하는 이름을 지어준다.
    1. 변수를 초기화 하는 코드가 있다면 추출한 함수에 넣는다.
3. 수정하고 나면 곧바로 컴파일하고 테스트해서 실수한 게 없는지 확인한다.
4. 함수를 추출하고 나면 지금보다 명확하게 표현할 수 있는 간단한 방법은 없는지 검토한다.
   가장 먼저 변수의 이름을 더 명학하게 바꿔보자.
    1. 필자는 변수명 totalAmount → result 로 변경
5. 임시 변수를 질의 함수로 바꾸기 → 변수 인라인하기

    ```jsx
    const play = playFor(perf);
    let thisAmount = amountFor(perf, play);
    
    => 인라인 적용
    ~~const play = playFor(perf);~~
    let thisAmount = amountFor(perf, playFor(perf));
    ```

6. 지역변수를 제거 해서 얻는 가장 큰 장점은 추출 작업이 훨씬 쉬워진다는 것이다. 유효범위를 신경 써야 할 대상이 줄어들기 때문이다.
7. 리팩터링은 이름을 잘 지어야만 효과가 있다.
   이름이 좋으면 함수 본문을 읽지 않고도 무슨 일을 하는지 알 수 있다.

> 반복문 쪼개기 로 변수 값을 누적시키는 부분을 분리한다.
문장 슬라이드하기 로 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮긴다.
함수 추출하기 로 적립 포인트 계산 부분을 별도 함수로 추출한다.
변수 인라인하기 로 voulumCredits 변수를 제거한다.
>

# 1.5 중간 점검 : 난무하는 중첩 함수

1. 계산 로직은 모두 여러개의 보조 함수로 빼낸다.
    1. 출력 로직과 계산로직의 분리 및 보조 함수로 구성
       → 계산과정 및 전체 흐름을 이해하기 훨씬 쉬워졌다.

# 1.6 계산 단계와 포맷팅 단계 분리하기

1. 필요한 데이터 처리 에 해당하는 코드와 HTML(출력) 코드의 분리
    1. 더불어 파일의 분리

# 1.7 중간 점검 : 두 파일(과 두 단계)로 분리됨

1. 계산하는 부분과 출력 형식을 다루는 부분이 분리됐다.
2. 모듈화하면 각 부분이 하는 일과 그 부분들이 맞물려 돌아가는 괒정을 파악하기 쉬워진다.
    1. 모듈화한 덕분에 계산 코드를 중복하지 않고도 HTML 버전을 만들 수 있었다.
3. 프로그래밍에서만큼은 명료함이 진화할 수 있는 소프트웨어의 정수다.

# 1.8 다형성을 활용해 계산 코드 재구성하기

1. 함수들을 계산기로 옮기기
    1. 가장 먼저 할 일은 공연료 계산 코드를 계산기 클래스 안으로 복사하는 것이다.
    2. 그런 다음 이 코드가 새 보금자리에서 잘 동작하도록 `aPerformance`를 `this.performance`로 바꾸고 `playFor(aPerformance)`를 `this.play`로 바꾼다.
2. 자바스크립트에서는 생성자가 서브클래스의 인스턴스를 반환할 수 없기 때문에 생성자를 `팩터리 함수로 바꾸기`를 적용한다.

# 1.9 상태 점검: 다형성을 활용하여 데이터 생성하기

1. 1.8의 수정으로 나아진 점은 연극 장르별 계산 코드들을 함께 묶어뒀다는 것이다.
2. 새로운 장르를 추가하려면 해당 장르의 서브클래스를 작성하고 생성 함수인 `createPerformanceCalculator()` 에 추가하기만 하면 된다.
3. 같은 타입의 다형성을 기반으로 실행되는 함수가 많을수록 예시처럼 구성하는 쪽이 유리하다.

# 1.10 마치며

<aside>
💡 좋은 코드를 가늠하는 확실한 방법은 ‘얼마나 수정하기 쉬운가’ 다.

</aside>

1. 각 단계에서 코드 구조를 보강했고, 그럴 때마다 코드가 수행하는 일이 더욱 분명하게 드러났다.