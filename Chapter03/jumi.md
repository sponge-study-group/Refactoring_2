## 3. 코드에서 나는 악취

### 3.1 기이한 이름

<br />

코드를 명료하게 표현하는 데 가장 중요한 요소 하는 바로 '이름'  
→ 함수, 모듈, 변수, 클래스 등은 `이름만 보고 무슨 일을 하고 어떻게 사용 하는지 알 수 있도록 지어야` 한다.

이름 바꾸기는 단순히 이름을 다르게 표현하는 연습 ✕  
→ 마땅한 이름이 떠오르지 않는다면 설게에 더 근본적인 문제가 숨어 있을 가능성 ○

---

### 3.2 중복 코드

<br />

똑같은 코드 구조가 여러 곳에서 반복  
→ 하나로 통합하여 더 나은 프로그램을 만들 수 있다.

한 클래스에 달린 두 메서드가 똑같은 표현식을 사용하는 경우  
→ **함수 추출하기**를 써서 양쪽 모두 추출된 메서드를 호출하도록 변경

코드가 완전히 똑같지는 않은 경우  
→ **문장 슬라이드**로 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴본다.

같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있다면  
→ 각자 따로 호출되지 않도록 **메서드 올리기**를 적용

---

### 3.3 긴 함수

<br />

코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점  
→ 함수를 짧게 구성할 때 나오는 것

> 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 `좋은 이름`이다.

주석을 달아야 할 만한 부분은 무조건 함수로 만든다.  
→ 함수 본문에는 원래 주석으로 설명하려던 코드가 담기고  
→ 함수 이름은 동작 방식이 아닌 '의도'가 드러나게 짓는다.

> '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다.

- 추출할 코드 덩어리를 찾는법

  1. 주석을 참고  
     → 주석은 코드만으로는 목적을 이해하기 어려운 부분에 달려 있다.  
     → 주석이 설명하는 코드와 함께 함수로 빼내고, 함수 이름은 주석 내용을 토대로 짓는다.  
     → 코드가 한 줄이어도 따로 설명할 필요가 있다면 함수로 추출하는게 좋다.

  2. 조건문  
     → 조건문 > **조건문 분해하기**  
     → switch문에서 각 case문마다 **함수 추출하기** 적용 > case의 본문을 함수 호출로 변경  
     → 같은 조건을 기준으로 나뉘는 switch문이 여러개 > **조건부 로직을 다형성으로 바꾸기**

  3. 반복문
     → 추출한 반복문 코드에 적합한 이름이 떠오르지 않는다면 **반복문 쪼개기**를 통해 작업을 분리

---

### 3.4 긴 매개변수 목록

<br />

다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있다면  
→ **매개변수를 질의 함수로 바꾸기**를 통해 제거

사용 중인 데이터 구조에서 값들을 뽑아 별개의 매개변수로 전달하는 코드  
→ **객체 통째로 넘기기**를 적용

함께 전달되는 매개변수  
→ **매개변수 객체 만들기**

함수의 동작 방식을 정하는 플래그 역할의 매개변수  
→ **플래그 인수 제거하기**

여러 개의 함수가 특정 매개변수들의 값들을 공통으로 사용  
→ **여러 함수를 클래스로 묶기**를 통해 공통 값들을 클래스의 필드로 정의

---

### 3.5 전역 데이터

<br />

전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아내기 힘들다.  
→ 버그는 끊임없이 발생하는데 그 원인이 되는 코드를 찾아내기가 어렵다.  
→ **변수 캡슐화하기**를 통해 방지  
→ 함수로 감싸는 것만으로도 데이터 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제 할 수 ○

전역 데이터가 많아지면 걷잡을 수 없게 된다.  
→ 전역 데이터가 조금만 있더라도 캡슐화하는 편  
→ 소프트웨어가 진화하는 데 따른 변화에 대처할 수 있다.

---

### 3.6 가변 데이터

<br />

값을 다른 곳에서 설정할 수 있는 가변 데이터  
→ **파생 변수를 질의 함수로 바꾸기**

변수의 유효범위가 넓어질 수록 가변 데이터에 따른 위험 ↑  
→ **여러 함수를 클래스로 묶기** or **여러 함수를 변환 함수로 묶기**를 활용  
→ 변수를 갱신하는 코드들의 유효범위를 제한

구조체처럼 내부 필드의 데이터를 담고 있는 변수  
→ **참조를 값으로 바꾸기**를 적용하여 구조체를 통째로 변경

---

### 3.7 뒤엉킨 변경

<br />

코드를 수정할 때는 시스템에서 고쳐야 할 딱 한 군데를 찾아서 그 부분만 수정  
→ 이렇게 할 수 없다면 뒤엉킨 변경과 산탄총 수술 중 하나가 된다.

뒤엉킨 변경  
→ 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생

순차적으로 실행되는 게 자연스러운 맥락  
→ 다음 맥락에 필요한 데이터를 특정한 데이터를 구조에 담아 전달하는 식으로 단계를 분리(**단계 쪼개기**)

전체 처리 과정 곳곳에서 각기 다른 맥락이 함수를 호출하는 빈도 ↑  
→ 여러 맥락에 관여하는 함수가 있다면 **함수 추출하기**를 통해 분리(모듈이 클래스라면 **클래스 추출하기**)  
→ 각 맥락에 해당하는 적당한 모듈들을 만들엉서 관련 함수들을 모은다(**함수 옮기기**).

---

### 3.8 산탄총 수술

<br />

산탄총 수술  
→ 코드를 변경할 때마다 수정해야 하는 클래스가 많을 때 발생  
→ 변경할 부분이 코드 전반에 퍼져 있다면 찾기도 어렵고 꼭 수정해야할 곳을 지나치기 쉽다.

함께 변경되는 부분  
→ **함수 옮기기**와 **필드 옮기기**로 모두 한 모듈에 묶어두면 좋다.

비슷한 데이터를 다루는 함수가 많다면  
→ **여러 함수를 클래스로 묶기**를 적용
→ 이렇게 묶은 함수들의 출력 결과를 묶어서 다음 단게의 로직으로 전달할 수 있다면 **단계 쪼개기**를 적용

어설프게 분리된 로직  
→ **함수 인라인하기**나 **클래스 인라인하기**와 같은 인라인 리팩터링을 통해 하나로 합치는 것도 좋은 방법

> 코드를 재구성하는 중간 과정에서는 큰 덩어리로 뭉쳐지는 데 개의치 않는다.

---

### 3.9 기능 편애

<br />

기능 편애  
→ 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 많을 때

외부 객체의 여러개의 게터 메서드를 호출  
→ **함수 옮기기**를 통해 데이터 근처로 옮겨준다.

함수 일부에서만 기능을 편애  
→ **함수 추출하기**를 통해 그 부분만 독립 함수로 뺀 다음, **함수 옮기기**를 통해 원하는 모듈로 보내준다.

함수가 사용하는 모듈이 다양하다면  
→ 가장 많은 데이터를 포함한 모듈을 옮긴다.  
→ **함수 추출하기**를 통해 함수를 여러 조각으로 나눈 후, 각각을 적합한 모듈로 옮기면 쉽게 해결

---

### 3.10 데이터 뭉치

<br />

필드 형태의 데이터 뭉치  
→ **클래스 추출하기**를 통해 하나의 객체로 묶는다.

메서드 시그니처에 있는 데이터 뭉치  
→ **매개변수 객체 만들기**나 **객체 통째로 넘기기**를 적용해서 매개변수 수 ↓

데이터 뭉치인지 판별  
→ 값 하나를 삭제했을 경우, 나머지 데이터만으로는 의미가 없다면 데이터 뭉치

기능 편애를 없애는 과정에서 새로운 클래스를 만들었다면, 그 클래스를 옮기면 좋을 동작은 없는지 살펴본다.  
→ 이러한 연계 과정을 통해 상당한 중복을 없애고 향후 개발을 가속하는 유용한 클래스를 만들 수 있다.

---

### 3.11 기본형 집착

<br />

**기본형을 객체로 바꾸기**를 적용하면 기본형만 존재하는 코드에서 자료형 코드로서 탈바꿈시킬 수 있다.

기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면  
→ **타입 코드를 서브클래스로 바꾸기**와 **조건부 로직을 다형성으로 바꾸기**를 차례로 적용

자주 몰려다는 기본형 그룹도 데이터 뭉치  
→ **클래스 추출하기**와 **매개변수 객체 만들기**를 통해 리팩터링 하자!

---

### 3.12 반복되는 switch문

<br />

똑같은 조건부 직이 여러 곳에서 반복해 등장하는 코드  
→ 조건이 하나씩 추가될 떄마다 다른 switch문들도 모두 함께 수정해야 하기 때문  
→ **조건부 로직을 다형성으로 바꾸기**를 통해 해결

---

### 3.13 반복문

<br />

**반복문을 파이프라인으로 바꾸기**를 적용해서 반복문을 제거

---

### 3.14 성의 없는 요소

<br />

본문 코드를 그대로 쓰는 것과 진배없는 함수나 실질적으로 메서드가 하나뿐인 클래스  
→ **함수 인라인하기**나 **클래스 인라인하기**를 통해 제거  
→ 상속을 사용했다면 **계층 합치기**를 적용

---

### 3.15 추측성 일반화

<br />

추측성 일반화  
→ 당장은 필요 없는 모든 종류의 hooking 포인트와 특이 케이스 처리 로직을 작성해둔 코드  
→ 사용하지 않는다면 쓸데없는 낭비

하는 일이 거의 없는 추상 클래스  
→ **게층 합치기**로 제거

쓸데없이 위임한느 코드  
→ **함수 인라인하기**나 **클래스 인라인하기**로 삭제

본문에서 사용되지 않는 매개변수  
→ **함수 선언 바꾸기**로 제거

테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스  
→ 테스트 케이스부터 삭제한 뒤, **죽은 코드 제거하기**로 제거

---

### 3.16 임시 필드

<br />

특정 상황에서만 값이 설정되는 필드를 가진 클래스  
→ 객체로 가져올 떄는 임시 필드를 갖게 된다.
→ **클래스 추출하기**를 통해 필요한 곳을 찾아주고  
→ **함수 옮기기**로 임시 필드들과 관련된 코드를 새 클래스에 몰아 넣는다.

임시 필드들이 유효한지를 확인한 후 동작하는 조건부 로직  
→ **특이 케이스 추가하기**로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어 제거

---

### 3.17 메시지 체인

<br />

메시지 체인  
→ 다른 객체로 요청하는 작업이 연쇄적으로 이어지는 코드

getSomething() 같은 getter가 꼬리에 꼬리를 물고 이어지거나 임시 변수들이 나열되는 코드  
→ **위임 숨기기**로 해결

모든 객체에 적용할 수 있지만, 중간 객체들이 모두 중개자가 되어버리기 쉽다.
→ **함수 추출하기**로 결과 객체를 사용하는 코드 일부를 따로 뺀 다음
→ **함수 옮기기**로 체인을 숨길 수 있는지 살펴봐야 한다.

<br />

```javascript
managerName = aPerson.department.manager.name;

managerName = aPerson.department.managerName; // 관리자 객체(manager)의 존재를 숨김
managerName = aPerson.manager.name; // 부서 객체(department)의 존재를 숨김
managerName = aPerson.managerName; // 관리자와 부서 객체 모두 존재를 숨김
```

이 체인의 최종 결과 객체는 name이 반환하는 부서장의 이름.  
객체가 아래와 같이 쓰인다고 가정해보자.

```javascript
managerName = aPerson.department.manager.name;
report = `${managerName}께 ${aPerson.name}님의 작업 로그 ...`;

console.log(report);
```

보고서 생성 로직을 함수로 추출한 다음 적당한 모듈로 옮기면 체인의 존재가 감춰진다.

```javascript
console.log(reportAutoGenerator.report(aPerson));
```

체인의 중간 부서 정보를 얻어 사용하는 다수의 클라이언트가 부서장 이름도 함께 사용한다면  
부서 클래스에 managerName() 메서드를 추가하여 체인을 단축할 수 있다.

---

### 3.18 중개자

<br />

캡슐화하는 과정에서 위임이 자주 활용.  
클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면  
→ **중개자 제거하기**를 활용하여 실제로 일을 하는 객체와 직접 소통하게 하자.  
→ 위임 메서드를 제거한 후, 남는 일이 거의 없다면 **함수 인라인하기**를 통해 수정

---

### 3.19 내부자 거래

<br />

조용히 데이터를 주고받는 모듈들  
→ **함수 옮기기**와 **필드 옮기기**를 통해 분리해서 사적으로 처리하는 부분을 줄인다.

여러 모듈이 같은 관심사를 공유  
→ 공통 부분을 처리하는 제 3의 모듈을 새로 만들거나 **위임 숨기기**를 이용하여 다른 모듈이 중간자 역할을 하게 만든다.

상속 구조에서 부모-자식 사이에 결탁이 생길 때  
→ 자식 클래스를 분리해야 할 때, **서브클래스를 위임으로 바꾸기**나 **슈퍼클래스를 위임으로 바꾸기**를 활용하자.

---

### 3.20 거대한 클래스

<br />

필드가 너무 많은 클래스
→ **클래스 추출하기**로 필드들 일부를 따로 묶는다.  
→ 한 클래스 안에서 접두어나 접미어가 같은 필드들이 함께 추출할 후보  
→ 분리할 컴포넌트를 원래 클래스와 상속 관계로 만드는 게 좋다면,  
**슈퍼클래스 추출하기**나 **타입 코드를 서브클래스로 바꾸기**를 적용!

코드량이 너무 많은 클래스  
→ 해당 클래스 안에서 자체적으로 중복을 제거

클라이언트가 거대 클래스를 이용하는 패턴을 파악하여 클래스를 쪼갤 수도 있다.  
→ 해당 클래스에서 주로 사용하는 특정 기능 그룹을 파악  
→ 이때 각각의 기능 그룹들을 앞서 설명한 방법 등을 활용하여 여러 클래스로 분리

---

### 3.21 서로 다른 인터페이스의 대안 클래스들

<br />

클래스를 다른 클래스로 교체할 때  
→ 교체하기 위해서는 동일한 인터페이스여야 한다.  
→ **함수 선언 바꾸기**를 통해 메서드 시그니처 일치  
→ 부족하다면, **함수 옮기기**를 이용하여 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어 넣는다.  
→ 대안 클래스들 사이에 중복 코드가 생기면 **슈퍼클래스 추출하기**을 고려

---

### 3.22 데이터 클래스

<br />

데이터 클래스  
→ 데이터 필드와 getter/setter 메서드로만 구성된 클래스  
→ 이러한 클래스가 public 필드에 있다면 **레코드 캡슐화하기**를 통해 숨기자.  
→ 변경하면 안되는 필드는 **세터 제거하기**를 통해 접근을 막는다.

다른 클래스에서 데이터 클래스의 getter나 setter를 사용하는 메서드를 찾으면  
→ **함수 옮기기**를 통해 메서드를 데이터 클래스로 옮길 수 있는지 살펴보자.  
→ 옮기기 어렵다면, **함수 추출하기**를 이용해서 별도 메서드로 추출한다.

**단계 쪼개기**의 결과로 나온 중간 데이터 구조는 불변이므로 굳이 캡슐화할 필요 ✖

---

### 3.23 상속 포기

<br />

서브클래스가 부모의 상속을 포기하는 경우  
→ 서브클래스가 부모의 동작을 필요로하지만 인터페이스는 따르고 싶지 않을 때  
→ **서브 클래스를 위임으로 바꾸기**나 **슈퍼클래스를 위임으로 바꾸기**를 활용해서 벗어나자.

---

### 3.24 주석

<br />

주석이 많으면 악취를 풍기는 코드가 나오기 쉽다.

특정 코드 블록이 하는 일에 주석을 남기고 싶다면 **함수 추출하기**를 적용  
→ 여전히 설명이 필요하다면 **함수 선언 바꾸기**를 통해 이름을 변경

시스템이 동작하기 위한 선행조건을 명시하고 싶다면  
→ **어서션 추가하기**(어떤 상태임을 가정한 채 실행)를 통해 리팩터링

> 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.

---
