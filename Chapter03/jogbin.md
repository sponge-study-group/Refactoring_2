# 제 3장 코드에서 나는 악취

> ‘적용 방법’을 아는 것과 ‘제때 적용’ 할 줄 아는 것은 다르다. 리팩터링을 언제 시작하고 언제 그만할지를 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지 않게 중요하다.
>

- 리팩터링을 언제 멈춰야 하는지를 판단하는 정확한 기준을 제시하지는 않을 것이다.
- 숙련된 사람의 직관만큼 정확한 기준은 없다.
- 리팩터링하면 해결할 수 있는 문제의 징후를 제시하겠다.

## 3.1 기이한 이름

1. 코드는 단순하고 명료하게 작성해야 한다.
2. 코드를 명료하게 표현하는데 가장 중요한 요소 하나는 바로 ‘이름’이다.
3. 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다.

## 3.2 중복 코드

1. 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우 → 함수추출하기
2. 코드가 비슷하긴 한데 완전히 똑같지는 않다면 → 문장 슬라이드 하기
3. 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있다면 → 메서드 올리기

## 3.3 긴 함수

1. 오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성됐다.
2. 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.
3. 물론 코드를 읽은 사람 입장에서는 함수가 하는 일을 파악하기 위해 왔다 갔다 해야 하므로 여전히 부담이 된다.
4. 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다.
5. 함수를 짧게 만드는 작업의 99%는 함수 추출하기 가 차지한다.
6. 그렇다면 추출할 코드 덩어리는 어떻게 찾아낼까?
    1. 주석은 코드만으로는 목적을 이해하기 어려운 부분에 달려 있는 경우가 많다.
    2. 이런 주석을 찾으면 주석이 설명하는 코드와 함께 함수로 빼내고, 함수 이름은 주석 내용을 토대로 짓는다.
7. 조건문이나 반복문도 추출 대상의 실마리를 제공한다.
    1. 거대한 switch문을 구성하는 case문마다 함수 추출하기를 적용해서 각 case의 본문을 함수 호출문 하나로 바꾼다.

## 3.4 긴 매개변수 목록

1. 종종 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있는데, 이런 매개변수는 매개변수를 질의 함수로 바꾸기 로 제거할 수 있다.
2. 클래스는 매개변수 목록을 줄이는 데 효과적인 수단이기도 하다. 특히 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 유용하다.

## 3.5 전역 데이터

1. 겪을 수 있는 악취 중 가장 지독한 축에 속한다.
2. 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 매커니즘이 없다는게 문제다.
3. 버그는 끊임없이 발생하는데 그 원인이 되는 코드를 찾아내기가 굉장히 어렵다.
4. 이를 방지하기 위해 우리가 사용하는 대표적인 리팩터링은 변수 캡슐화하기 다.

## 3.6 가변 데이터

1. 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본을 삼고 있다.
2. 가령 변수 캡슐화하기 를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다.
3. 다른 곳에서 설정할 수 있는 가변 데이터가 풍기는 악취는 특히 고약하다. 혼동과 버그와 야근을 부를 뿐만 아니라, 쓸데없는 코드이기도 하다.
    1. 이럴 때는 파생 변수를 질의 함수로 바꾸기에 식초 농축액을 섞어서 코드 전체에 골고루 뿌려준다.

## 3.7 뒤엉킨 변경

1. 데이터베이스 연동과 금융 상품 처리는 서로 다른 맥락에서 이뤄지므로 독립된 모듈로 분리해야 프로그래밍이 편하다. 그래야 무언가를 수정할 때 해당 맥락의 코드만 이해해도 진행할 수 있다.

## 3.8 산탄총 수술

1. 이 냄새는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다.
2. 어설프게 분리된 로직을 함수 인라인하기 나 클래스 인라인하기 같은 인라인 리팩터링으로 하나로 합치는 것도 산탄총 수술에 대처하는 좋은 방법이다.

## 3.9 기능 편애

1. 기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 풍기는 냄새다.
2. 함수가 데이터와 가까이 있고 싶어 한다는 의중이 뚜렷이 드러나므로 소원대로 데이터 근처로 옮겨주면 된다. → 함수 옮기기
3. 어디로 옮길지가 명확하게 드러나지 않을 때도 있다.
    1. 우리는 가장 많은 데이터를 포함한 모듈로 옮긴다.
    2. 함수 추출하기 로 함수를 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮기면 더 쉽게 해결되는 경우도 많다.

## 3.10 데이터 뭉치

1. 항목 서너 개가 여러 곳에서 항상 함께 뭉쳐 다니는 모습을 흔히 목격할 수 있다. 클래스 두어 개의 필드에서, 혹은 여러 메서드의 시그니처에서 함께 발견되기도 한다. 이렇게 몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야 마땅하다.
2. 데이터 뭉치인지 판별하려면 값 하나를 삭제해보자. 그랬을 때 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻이다.

## 3.11 기본형 집착

1. 전화번호를 단순히 문자 집합으로만 표현하기엔 아쉬움이 많다. 최소한 사용자에게 보여줄 때는 일관된 형식으로 출력해주는 기능이라도 갖춰야 한다. 이런 자료형들을 문자열로만 표현하는 악취는 아주 흔해서, 소위 ‘문자열화된 변수’ 라는 이름까지 붙었다.
2. 자주 함께 몰려다니는 기본형 그룹도 데이터 뭉치다. 따라서 클래스 추출하기 와 매개변수 객체 만들기를 이용하여 반드시 문명사회로 이끌어줘야 한다.

## 3.12 반복되는 switch문

1. 중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 하기 때문이다. 이럴 때 다형성은 반복된 switch문이 내뿜는 사악한 기운을 제압하여 코드베이스를 최신 스타일로 바꿔주는 세련된 무기인 셈이다.

## 3.13 반복문

1. 지금은 일급 함수를 지원하는 언어가 많아졌기 때문에 반복문을 파이프라인으로 바꾸기 를 적용해서 시대에 걸맞지 않는 반복문을 제거할 수 있게 됐다.

## 3.15 추측성 일반화

1. 이 냄새는 ‘나중에 필요할 거야’ 라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스처리 로직을 작성해둔 코드에서 풍긴다.
2. 당장 걸리적거리는 코드는 눈앞에서 치워버리자
3. 나중에 다른 버전을 만들 때 필요할 거라는 생각에 추가했지만 한 번도 사용한 적 없는 매개변수도 이 기법으로 제거한다.

## 3.16 임시 필드

1. 간혹 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다.
2. 이렇게 덩그러니 떨어져 있는 필드들을 발견하면 클래스 추출하기로 살 곳을 찾아준다.
3. 임시 필드들이 유효한지를 확인한 후 동작하는 조건부 로직이 있을 수 있는데, 특이 케이스 추가하기 로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어서 제거할 수 있다.

## 3.17 메시지 체인

1. 메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.
2. 내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다.
3. 최종 결과 객체가 어떻게 쓰이는지부터 살펴보는게 좋다.

## 3.18 중개자

1. 객체의 대표적인 기능 하나로, 외부로부터 세부사항을 숨겨주는 캡슐화가 있다.
2. 캡슐화 하는 과정에서는 위임이 자주 활용된다.
3. 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면 어떤가?
    1. 이럴 때는 중개자 제거하기를 활용하여 실제로 일을 하는 객체와 직접 소통하게 하자.
    2. 위임 메서드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인하자

## 3.19 내부자 거래

1. 여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 제3의 모듈을 새로 만들거나 위임 숨기기 를 이용하여 다른 모듈이 중간자 역할을 하게 만든다.
2. 상속 구조에서는 부모 자식 사이에 결탁이 생길 때가 있다.
    1. 자식 클래스는 항상 부모 클래스가 공개하고 싶은 것 이상으로 부모에 대해 알려고 한다.
    2. 그러다가 부모 품을 떠나야 할 때가 온다면 서브클래스를 위임으로 바꾸기 나 슈퍼클래스를 위임으로 바꾸기 를 활용하자

## 3.20 거대한 클래스

1. 한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어난다. 그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.
    1. 이럴 때는 클래스 추출하기 로 필드들 일부를 따로 묶는다.
2. 필드가 너무 많은 클래스와 마찬가지로 코드량이 너무 많은 클래스도 중복 코드와 혼동을 일으킬 여지가 크다.
    1. 가장 간단한 해법은 그 클래스 안에서 자체적으로 중복을 제거하는 것이다.
    2. 가령 부분부분 상당량의 로직이 똑같은 100줄짜리 메서드 다섯 개가 있다면 각각의 공통 부분을 작은 메서드들로 뽑아내자. 그러면 원래의 다섯 메서드들에는 작은 메서드들을 호출하는 코드 10줄만 남게 될지도 모른다.

## 3.21 서로 다른 인터페이스의 대안 클래스들

1. 클래스를 사용할 때의 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것이다.
    1. 교체하려면 인터페이스가 같아야 한다. 따라서 함수 선언 바꾸기 로 메서드 시그니처를 일치시킨다.
    2. 때로는 이것만으로 부족한데, 이럴 때는 함수 옮기기 를 이용하여 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어 넣는다.
    3. 그러다 대안 클래스들 사이에 중복 코드가 생기면 슈퍼클래스 추출하기를 적용할지 고려해본다.

## 3.22 데이터 클래스

1. 클래스에 public 필드가 있다면 누가 보기 전에 얼른 레코드 캡슐화하기 로 숨기자.
2. 변경하면 안 되는 필드는 세터 제거하기 로 접근을 원천 봉쇄한다.
3. 클라이언트 코드를 데이터 클래스로 옮기기만 해도 대폭 개선된다.
4. 불변 필드는 굳이 캡슐화할 필요가 없고, 불변 데이터로부터 나오는 정보는 게터를 통하지 않고 그냥 필드 자체에 공개해도 된다.

## 3.23 상속 포기

1. 서브클래스는 부모로부터 메서드와 데이터를 물려받는다. 하지만 부모와 유산을 원치 않거나 필요 없다면 어떻게 해야할까?
    1. 수많은 유산 중에서 관심 있는 몇 개만 받고 끝내려는 경우는 얼마든지 있을 수 있다.
2. 상속 포기 냄새는 서브클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을 때 특히 심하게 난다. 구현을 따르지 않는 것은 이해할 수 있지만 인터페이스를 따르지 않는다는 것은 상당히 무례한 태도다.
    1. 이럴 때는 서브클래스를 위임으로 바꾸기 나 슈퍼클래스를 위힘으로 바꾸기 를 활용해서 아예 상속 메커니즘에서 벗어나보자

## 3.24 주석

<aside>
💡 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.

</aside>

1. 주석은 악취가 아닌 향기를 입힌다. 문제는 주석을 탈취제처럼 사용하는 데 있다. 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 의외로 많다.
2. 특정 코드 블록이 하는 일에 주석을 남기고 싶다면 함수 추출하기 를 적용해본다.
3. 이미 추출되어 있는 함수임에도 여전히 설명이 필요하다면 함수 선언 바꾸기 로 함수 이름을 바꿔본다.
4. 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 어선셔 추가하기 가 대기하고 있다.