# [3] 코드에서 나는 악취

리팩터링이 어떻게 작동하는지는 감이 왔겠지만, ‘적용 방법’을 아는 것과 ‘제때 적용’할 줄 아는 것은 다르다.

리팩터링을 언제 시작하고 언제 그만할지를 판단하는 일은 작동 원리를 아는 것 못지않게 중요하다.

하지만 리팩터링을 ‘언제’ 해야 하는지에 대해서 명확하게 정립된 규칙이 없다.

이 주제로 켄트벡은 리팩터링할 ‘시점’을 설명하는 데 ‘냄새’란 표현을 사용했다.

우리는 리팩터링이 필요한, 때로는 아주 절실한 코드들에 일정한 패턴이 있다는 사실을 발견했다.

하지만 리팩터링을 언제 멈춰야 하는지를 판단하는 정확한 기준은 제시하지는 않을 것이다.

종료 기준보다는 리팩터링하면 해결할 수 있는 문제의 징후를 제시하겠다.

먼저 이 장을 읽고 코드가 풍기는 냄새(악취)가 무엇인지 찾자.

그런 다음 리팩터링 기법을 이 책의 6~12장에서 찾아 읽고 냄새를 없애는 데 도움이 될지 생각해본다.

## 1. 기이한 이름(Mysterious Name)

코드는 단순하고 명료하게 작성해야 한다.

그를 표현하는 데 가장 중요한 요소 중 하나는 바로 ‘이름’이다.

이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 지어야 한다.

아쉽게도 이름 짓기는 프로그래밍에서 가장 어렵기로 손꼽히는 두 가지 중 하나다.

그렇기 때문에 우리가 가장 많이 사용하는 리팩터링도

**함수 선언 바꾸기**, **변수 이름 바꾸기**, **필드 이름 바꾸기**처럼 이름을 바꾸는 리팩터링들이다.

이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니다.

마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.

## 2. 중복 코드(Duplicated Code)

코드가 중복되면 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생긴다.

그중 하나를 변경할 때는 다른 비슷한 코드들도 모두 살펴보고 적절히 수정해야 한다.

간단한 예로, 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우가 있다.

이럴 때는 **함수 추출하기**를 써서 양쪽 모두 추출된 메서드를 호출하게 바꾸면 된다.

비슷하긴 한데, 완전히 똑같지는 않다면, 먼저 **문장 슬라이드하기**로

비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴본다.

같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있다면,

각자 따로 호출되지 않도록 **메서드 올리기**를 적용해 부모로 옮긴다.

## 3. 긴 함수(Long Function)

짧은 함수들로 구성된 코드베이스는 끝없이 위임하는 방식으로 작성되어 있기에 얼핏 훑으면 연산하는 부분이 하나도 없어 보인다.

간접 호출의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.

예전 언어는 서브루틴을 호출하는 비용이 컸기 때문에 짧은 함수를 꺼렸다.

하지만 요즘 언어는 프로세스 안에서의 함수 호출 비용을 거의 없애버렸다.

물론 코드를 읽는 사람은 함수가 하는 일을 파악하기 위해 왔다 갔다 해야 하므로 여전히 부담된다.

함수 호출부, 선언부를 빠르게 이동하거나 호출과 선언을 동시에 보여주는 개발 환경을 활용하면 부담이 줄어들지만,

짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다.

함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다.

그러기 위해서는 더 적극적으로 함수를 쪼개야 한다.

주석을 달아야 할 만한 부분은 무조건 함수로 만든다.

함수 이름은 동작 방식이 아닌 ‘의도’가 드러나게 짓는다.

이런 함수들은 여러 줄일 수도 있고 단 한 줄일 수도 있다.

원래 코드보다 길어지더라도 함수로 뽑는다. 단, 함수 이름에 코드의 목적을 드러내야 한다.

‘무엇을 하는지’ 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리하다.

함수를 짧게 만드는 작업의 99%는 **함수 추출하기**가 차지한다.

함수가 매개변수와 임시 변수를 많이 사용한다면 추출 작업에 방해가 된다.

**임시 변수를 질의 함수로 바꾸기**로 임시 변수의 수를,

**매개변수 객체 만들기**와 **객체 통째로 넘기기**로는 매개변수의 수를 줄일 수 있을 것이다.

이 리팩터링들을 적용해도 임시 변수와 매개변수가 많다면, **함수를 명령으로 바꾸기**를 고려해보자.

추출할 코드 덩어리를 찾아내는 방법은 주석을 참고하는 것이다.

코드가 단 한 줄이어도 따로 설명할 필요가 있다면 함수로 추출하는 게 좋다.

조건문이나 반복문도 추출 대상의 실마리를 제공한다.

조건문은 **조건문 분해하기**로 대응한다.

거대한 switch문을 구성하는 case문마다 **함수 추출하기**를 적용한다.

같은 조건을 기준으로 나뉘는 switch문이 어려 개라면 **조건부 로직을 다형성으로 바꾸기**를 적용한다.

반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만든다.

추출한 반복문 코드에 적합한 이름이 떠오르지 않는다면 다른 두 가지 작업이 섞여 있기 때문일 수 있다.

이럴 때는 과감히 **반복문 쪼개기**를 적용해서 작업을 분리한다.

## 4. 긴 매개변수 목록(Long Parameter List)

매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.

다른 매개변수에서 값을 얻어올 수 있는 매개변수는 **매개변수를 질의 함수로 바꾸기**로 제거하라.

사용 중인 데이터 구조에세 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면

**객체 통째로 넘기기**를 적용해서 원본 데이터 구조를 그대로 전달한다.

항상 함께 전달되는 매개변수들은 **매개변수 객체 만들기**로 하나로 묶어버린다.

함수의 동작 방식을 정하는 플래그 역할의 매개변수는 **플래그 인수 제거하기**로 없애준다.

클래스는 매개변수 목록을 줄이는 데 효과적인 수단이기도 하다.

특히 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 유용하다.

이럴 때는 **여러 함수를 클래스로 묶기**를 이용하여 공통 값들을 클래스의 필드로 정의한다.

## 5. 전역 데이터(Global Data)

전역데이터는 우리가 겪을 수 있는 악취 중 가장 지독한 축에 속한다.

코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제다.

전역 데이터의 대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤에서도 같은 문제가 발생한다.

이를 방지할 때는 **변수 캡슐화하기**를 사용한다.

더 나아가 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 줄여라.

전역 데이터가 가변이라면 특히나 다루기 까다롭다.

전역 데이터가 아주 조금만 있더라도 캡슐화하는 편이다.

## 6. 가변 데이터(Mutable Data)

가변 데이터는 오류가 발생하면 원인을 찾기 매우 어렵다.

이런 이유로 함수형 프로그래밍에서 데이터의 기본 개념은 불변이다.

**변수 캡슐화하기**를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 코드를 개선하기 쉽다.

변수가 용도가 다른 값들을 저장하느라 갱신하는 경우엔 **변수 쪼개기**를 이용해서 용도별로 독립 변수를 만든다.

갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋다.

**문장 슬라이드하기**와 **함수 추출하기**를 통해 갱신하는 코드로부터 부작용이 없는 코드를 분리한다.

API를 만들 때는 **질의 함수와 변경 함수 분리하기**를 활용해 부작용이 있는 코드를 호출할 수 없게 한다.

가능한 **세터 제거하기**도 적용한다.

값을 다른 곳에서 설정할 수 있는 가변 데이터는 특히 고약하다.

**파생 변수를 질의 함수로 바꾸기**를 적용하자.

변수 유효범위가 작아도 추후에 넓어질 수 있기 때문에 **여러 함수를 클래스로 묶기**나

**여러 함수를 변환 함수로 묶기**를 활용해 갱신하는 코드들의 유효범위를 제한한다.

구조체처럼 내부 필드에 데이터를 담고 있는 변수는

**참조를 값으로 바꾸기**를 적용해 내부 필드를 수정하지 말고 구조체를 통째로 바꾸는 편이 낫다.

## 7. 뒤엉킨 변경(Divergent Change)

소프트웨어의 구조를 변경하기 쉬운 형태로 조직한다.

코드를 수정할 때는 시스템에서 고쳐야 할 딱 한 군데를 찾아서 그 부분만 수정할 수 있기를 바란다.

그렇지 않다면 뒤엉킨 변경과 산탄총 수술 중 하나가 풍긴다.

뒤엉킨 변경은 단일 책임 원칙(SRP)이 제대로 지켜지지 않을 때 나타난다.

데이터를 먼저 받은 후 처리하는 것처럼 순차적으로 실행되야 한다면, 다음 맥락에 필요한 데이터를

특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리한다.(**단계 쪼개기**)

전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면,

적당한 모듈들을 만들어서 관련 함수들을 모은다(**함수 옮기기**)

그러면 처리 과정이 맥락별로 분리된다.

이때 여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전에 **함수 추출하기**부터 수행한다.

모듈이 클래스라면 **클래스 추출하기**가 맥락별 분리 방법을 잘 안내해줄 것이다.

## 8. 산탄총 수술(Shotgun Surgery)

산탄총 수술은 뒤엉킨 변경과 비슷하면서도 정반대다.

코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다.

이럴 때는 함께 변경되는 대상들을 **함수 옮기기**나 **필드 옮기기**로 한 모듈에 묶어두면 좋다.

비슷한 데이터를 다루는 함수가 많다면 **여러 함수를 클래스로 묶기**를 적용한다.

데이터 구조를 변환하거나 보강하는 함수들에는 **여러 함수를 변환 함수로 묶기**를 적용한다.

이런 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 **단계 쪼개기**를 적용한다.

어설프게 분리된 로직을 **함수 인라인하기**나 **클래스 인라인하기**같은 인라인 리팩터링으로 합치는 것도 좋은 방법이다.

메서드나 클래스가 비대해지지만, 나중에 추출하기 리팩터링으로 더 좋은 형태로 분리할 수 있다.

사실 작은 함수와 클래스에 지나칠 정도로 집착하지만, 코드를 재구성할때는 큰 덩어리로 뭉쳐지는데 개의치 않는다.

## 9. 기능 편애(Feature Envy)

프로그램을 모듈화할 때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 상호작용은 최대한 늘리고

영역 사이에서 이뤄지는 상호작용은 최소로 줄이는 데 주력한다.

기능 편애는 흔히 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 많을 때 풍기는 냄새다.

해결하기는 쉽다. 이 함수를 외부 객체 근처로 옮겨 주면 된다(**함수 옮기기**)

때로는 함수의 일부에서만 기능을 편애할 수 있는데, 그 부분을 독립 함수로 빼낸 다음(**함수 추출하기**) 원하는 모듈로 보내준다.(**함수 옮기기**)

어디로 옮길지 명확하지 않다면, 가장 많은 데이터를 포함한 모듈로 옮기고, 이때 **함수 추출하기**로 조각조각 나누면 더 쉽다.

한편, 앞 두 문단에서 설명한 규칙을 거스르는 복잡한 패턴도 있다.

디자인 패턴 중 전략 패턴(Strategy Pattern), 방문자 패턴(Visitor Pattern)이 있다.

켄트 벡의 자기 위임(Self-Delegation)도 여기에 속한다.

이들은 모두 뒤엉킨 변경 냄새를 없앨 때 활용하는 패턴으로, 가장 기본이 되는 원칙은 ‘함께 변경할 대상을 한데 모으는 것’이다.

데이터와 이를 활용하는 동작은 함께 변경해야 할 때가 많지만, 예외가 있다.

그럴 때는 같은 데이터를 다루는 코드를 한 곳에서 변경할 수 있도록 옮긴다.

전략 패턴과 방문자 패턴을 적용하면 오버라이드해야 할 소량의 동작 코드를 각각의 클래스로 격리해주므로 수정하기가 쉬워진다.

(대신 간접 호출이 늘어난다)

## 10. 데이터 뭉치(Data Clumps)

데이터 항목 서너 개가 여러 곳에서 함께 뭉쳐 다니는 모습을 흔히 목격할 수 있다.

필드 형태의 데이터 뭉치를 찾아서 **클래스 추출하기**로 하나의 객체로 묶는다.

메서드 시그니처에 있는 데이터 뭉치는 먼저 **매개변수 객체 만들기**나 **객체 통째로 넘기기**를 적용해서 매개변수 수를 줄여본다.

그 즉시 메서드 호출 코드가 간결해질 것이다.

데이터 뭉치가 앞에서 새로 만든 객체의 필드 중 일부만 사용하더라도 걱정할 필요 없다.

새 객체로 뽑아낸 필드가 두 개 이상이기만 해도 확실히 예전보다 나아지기 때문이다.

데이터 뭉치인지 판별하려면 값 하나를 삭제해보라. 나머지 데이터만으로 의미가 없다면 데이터 뭉치이다.

방금 설명에서 간단한 레코드 구조가 아닌 ‘클래스’로 만들기를 권했음을 눈치챘는가?

클래스를 이용하라. 기능 편애를 없애는 과정에서 새로운 클래스를 생성했다면, 이어서 그 클래스로 옮기면 좋을 동작은 없는지 살펴보자.

이러한 연계 과정은 종종 상당한 중복을 없애고 유용한 클래스를 탄생시킨다.

## 11. 기본형 집착 (Primitive Obsession)

자신에게 주어진 문제에 딱 맞는 기초 타입(화폐, 좌표, 구간 등)을 직접 정의하기를 몹시 꺼리는 사람이 많다.

그래서 금액을 그냥 숫자형으로 계산하거나, 밀리미터나 인치 같은 단위를 무시하고,

범위도 if(a < upper && a > lower) 처럼 하는 코드를 수 없이 봤다.

이 냄새는 문자열을 다루는 코드에서 특히 흔하다.

최소한 사용자에게 보여줄 때는 일관된 형식으로 출력해주는 기능이라도 갖춰야 한다.

이런 자료형들을 문자열로만 표현하는 악취는 아주 흔해서, 소위 ‘문자열화된 변수’라는 이름까지 붙혔다.

**기본형을 객체로 바꾸기**를 적용하라.

기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면

**타입 코드를 서브 클래스로 바꾸기**와 **조건부 로직을 다형성으로 바꾸기**를 차례로 적용한다.

자주 함께 몰려다니는 기본형 그룹도 데이터 뭉치다.

따라서 **클래스 추출하기**와 **매개변수 객체 만들기**를 이용하라.

## 12. 반복되는 switch문 (Repeated Swtiches)

어떤 이는 코드에서 등장하는 switch문은 모조리 **조건부 로직을 다형성으로 바꾸기**로 없애야 할 대상이라고 주장한다.

심지어 리팩터링 후 if문까지도 대부분 지워야 한다고 주장하는 이도 있다.

이제는 똑같은 조건부 로직(switch문이나 길게 나열된 if/else문)이 여러 곳에서 반복해 등장하는 코드에 집중하라.

중복된 switch문은 조건절을 추가할 때마다 다른 switch문들도 모두 함께 수정해야 하기 때문이다.

이럴 때 다형성은 반복된 switch문의 문제점을 확실히 잡아준다.

## 13. 반복문 (Loops)

**반복문을 파이프라인으로 바꾸기**를 적용해서 반복문을 제거할 수 있다.

filter나 map 같은 파이프라인 연산을 사용하면 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다.

## 14. 성의 없는 요소 (Lazy Element)

우리는 코드의 구조를 잡을 때 프로그램 요소를 이용하는 걸 좋아한다.

```
프로그램 요소
프로그래밍 언어가 제공하는 함수, 클래스, 인터페이스 등 코드 구조를 잡는데 활용되는 요소
```

하지만, 쓸모 없는 경우가 더러 있다.

이 제거 작업은 흔히 **함수 인라인하기**나 **클래스 인라인하기**로 처리한다.

상속을 사용했다면 **계층 합치기**를 적용한다.

## 15. 추측성 일반화 (Speculative Generality)

‘나중에 필요할 거야’라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직 코드에서 풍긴다.

그 결과는 물론 이해하거나 관리하기 어려워진 코드다.

미래를 대비한 코드는 사용되면 다행이지만, 아니라면 쓸데없는 낭비다. 지워라.

하는 일이 거의 없는 추상 클래스는 **계층 합치기**로 제거한다.

쓸데없이 위임하는 코드는 **함수 인라인하기**나 **클래스 인라인하기**로 삭제한다.

본문에서 사용되지 않는 매개변수는 **함수 선언 바꾸기**로 없앤다.

추측성 일반화는 테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스에서 흔히 볼 수 있다.

이런 코드를 발견하면 테스트 케이스부터 삭제한 뒤에 **죽은 코드 제거하기**로 날려버리자.

## 16. 임시 필드 (Temporary Field)

객체를 가져올 때는 당연히 모든 필드가 채워져 있으리라 기대하지만,

간혹 특정 상황에만 값이 설정되는 필드를 가진 클래스도 있다.

그래서 사용자는 쓰이지 않는 것처럼 보이는 필드가 존재하는 이유를 파악하느라 머리가 아프다.

이런 필드들은 **클래스 추출하기**로 제 살곳을 찾아준 후,

**함수 옮기기**로 임시 필드들과 관련된 코드를 모조리 새 클래스에 몰아넣는다.

또한 임시 필드들이 유효한지를 확인한 후 동작하는 조건부 로직은

**특이 케이스 추가하기**로 유효하지 않을 때를 위한 대안 클래스를 만들어 제거하라.

## 17. 메시지 체인 (Message Chains)

클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 코드를 말한다.

이는 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미한다.

그래서 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다.

이 문제는 **위임 숨기기**로 해결한다. 이 리팩터링은 다양한 연결점에 적용할 수 있다.

원칙적으로 체인을 구성하는 모든 객체에 적용할 수 있지만, 중간 객체들이 모두 중개자가 돼버리기 쉽다.

그러니 최종 결과 객체가 어떻게 쓰이는지부터 살펴보는게 좋다.

**함수 추출하기**로 결과 객체를 사용하는 코드 일부를 따로 빼낸 다음 **함수 옮기기**로 체인을 숨길 수 있는지 살펴보자.

체인을 구성하는 객체 중 특정 하나를 사용하는 클라이언트 중 그 이후의 객체들도

사용하길 원하는 클라이언트가 많다면, 이 요구를 처리해줄 메서드를 추가한다.

```jsx
managerName = aPerson.department.manager.name;

managerName = aPerson.department.name; // 관리자 객체(manager)의 존재를 숨김
managerName = aPerson.manager.name; // 부서 객체 (department)의 존재를 숨김
managerName = aPerson.managerName; // 관리자, 부서 객체를 모두 숨김
```

```jsx
managerName = aPerson.department.manager.name;
report = `${managerName}께
${aPerson.name} 님의 작업 로그
...`;
console.log(report);

console.log(reportAutoGenerator.report(aPerson));
```

## 18. 중개자 (Middle Man)

객체의 대표적인 기능 하나로, 외부로부터 세부사항을 숨겨주는 캡슐화가 있다.

캡슐화하는 과정에서는 위임이 자주 활용된다.

하지만 지나치면 문제가 된다. 클래스가 제공하는 메서드 중 다수가 다른 클래스에 구현을 위임한다면

**중개자 제거하기**를 활용하여 실제로 일을 하는 객체와 직접 소통하게 하자.

위임 메서드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인하자 (**함수 인라인하기**)

## 19. 내부자 거래 (Insider Trading)

모듈 사이의 데이터 거래가 많으면 결합도가 높아졌다는 뜻이다.

거래가 이루어질 수 밖에 없지만, 그 양을 최소로 줄이고 모두 투명하게 처리해야 한다.

은밀히 데이터를 주고 받는 모듈이 있다면 **함수 옮기기**와 **필드 옮기기** 기법으로 투명하게 처리하게 만들자.

여러 모듈이 같은 관심사를 공유한다면 정식적인 제 3의 모듈을 만들거나 **위임 숨기기**로 다른 모듈이 중간자 역할을 하게 만든다.

자식 클래스는 항상 부모 클래스가 공개하고 싶은 것 이상으로 부모에 대해 알려고 한다.

그러다 부모 품을 떠나야할 때가 온다면 **서브 클래스를 위임으로 바꾸기**나 **슈퍼클래스를 위임으로 바꾸기**를 활용하자.

## 20. 거대한 클래스 (Large Class)

한 클래스가 너무 많은 일을 하려다 보면 필드 수가 늘어나고 중복 코드가 생기기 쉽다.

우선 **클래스 추출하기**로 비슷한 성질의 필드들 일부를 따로 묶는다.

일반적으로는, 한 클래스 안에서 접두어나 접미어가 같은 필드들이 함께 추출할 후보들이다.

이렇게 분리할 컴포넌트를 원래 클래스와 상속관계로 만드는 게 좋다면 **클래스 추출하기**보단 **슈퍼클래스 추출하기**나

**타입코드를 서브클래스로 바꾸기(서브 클래스 추출하기)**를 적용하는 편이 더 쉬울 것이다.

마찬가지로 코드량이 너무 많은 클래스도 중복 코드와 혼동을 일으킬 여지가 크다.

가장 간단한 해법은 자체적으로 중복을 제거하는 것이다.

클라이언트들이 거대 클래스를 이용하는지 패턴을 파악하여 쪼갤 단서를 얻을 수도 있다.

먼저 거대 클래스의 특정 기능 그룹만 주로 사용하는지 살핀다.

이때 각각의 기능이 개별 클래스로 추출될 후보다.

유용한 기능 그룹을 찾았다면 **클래스 추출하기**, **슈퍼클래스 추출하기**, **타입 코드를 서브클래스로 바꾸기** 등을 활용하자.

## 21. 서로 다른 인터페이스의 대안 클래스들

(Alternative Classes with Different Interfaces)

클래스는 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 장점이 있다.

단, 인터페이스가 같아야 한다.

따라서 **함수 선언 바꾸기**로 메서드 시그니처를 일치시킨다.

때로는 이것만으론 부족해 **함수 옮기기**를 이용하여 인터페이스가 같아질 때까지 필요한 동작을 클래스에 추가한다.

그러다 대안 클래스들 사이에 중복 코드가 생기면 **슈퍼클래스 추출하기**를 적용할지 고려하라.

## 22. 데이터 클래스 (Data Class)

데이터 필드와 게터/세터 메서드로만 구성된 클래스를 데이터 클래스라 한다.

데이터 저장 용도로만 쓰이다 보니 다른 클래스가 너무 깊이까지 함부로 다룰 때가 많다.

이런 클래스에 public 필드가 있다면 **레코드 캡슐화하기**로 숨기고, 변경하면 안 되는 필드는 **세터 제거하기**를 하자.

다른 클래스에서 데이터 클래스의 게터/세터를 사용하는 메서드를 찾아서 **함수 옮기기**로 옮길 수 있는지 확인하자.

메서드를 통째로 옮기기 어렵다면 **함수 추출하기**를 이용해 옮길 수 있는 부분만 별도 메서드로 뽑아낸다.

한편, 데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의돼 있다는 신호일 수 있다.

이런 경우 클라이언트 코드를 데이터 클래스로 옮기기만 해도 대폭 개선된다.

물론 예외도 있다. 특히 다른 함수를 호출해 얻은 결과 레코드(데이터 객체)로는 동작 코드를 넣을 필요가 없다.

대표적인 예로 **단계 쪼개기**의 결과로 나온 중간 데이터 구조가 있다. 이런 데이터 구조는 불변이다.

불변 필드는 굳이 캡슐화할 필요가 없다.

## 23. 상속 포기 (Refused Bequest)

서브 클래스는 부모로부터 메서드와 데이터를 물려받는데, 원치 않거나 필요 없는 경우가 있다.

계층 구조를 잘못 설계했을 경우에는 같은 계층에 서브 클래스를 하나 만들고,

**메서드 내리기**와 **필드 내리기**를 활용해서 필요 없는 부모 코드를 모조리 넘긴다.

한걸음 나아가서 부모 클래스는 모두 추상 클래스여야 한다고 말하는 사람도 많다.

하지만 이 방식을 권하지는 않는다.

상속 포기 냄새는 서브클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을 때 특히 심하게 난다.

이럴 때는 **서브클래스를 위임으로 바꾸기**나 **슈퍼클래스를 위임으로 바꾸기**를 활용해 상속 매커니즘에서 벗어나자.

## 24. 주석 (Comments)

주석을 달지 말라는 이야기는 아니다.

허나, 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 의외로 많다.

특정 코드 블록이 하는 일에 주석을 남기고 싶다면 **함수 추출하기**를 적용해본다.

이미 추출되어 있는 함수라면, **함수 선언 바꾸기**로 함수 이름을 바꿔본다.

시스템이 동작하기 위한 선행조건을 명시하고 싶다면 **어서션 추가하기**를 해보자.

<aside>
🗒️ 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.

</aside>
