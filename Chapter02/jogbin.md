# 제 2장 리팩터링 원칙

## 2.1 리팩터링 정의


> 누군가 “리팩터링하다가 코드가 깨져서 며칠이나 고생했다” 라고 한다면, 십중팔구 리팩터링한 것이 아니다.


1. 지금껏 수많은 사람이 코드를 정리하는 작업을 모조리 ‘리팩터링’이라고 표현하고 있는데, 이 책에서 제시한 정의를 따르면 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다.
2. 코드베이스를 잘게 나눔으로써 오히려 작업을 더 빨리 처리할 수 있다.
   단계들이 체계적으로 구성되어 있기도 하고, 무엇보다 디버깅하는 데 시간을 뺏기지 않는다.
3. 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다.
4. 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다.
   프로그램 성능은 좋아질 수도, 나빠질 수도 있다.

## 2.2 두 개의 모자

1. 기능을 추가할 때는 ‘기능 추가’ 모자를 쓴 다음 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다.
2. 리팩터링할 때는 ‘리팩터링’ 모자를 쓴 다음 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다.

## 2.3 리팩터링하는 이유

1. 리팩터링이 코드를 건강한 상태로 유지하는 데 도와주는 약임은 분명하다.
2. 리팩터링하면 소프트웨어 설계가 좋아진다.
    1. 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.
    2. 반면 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다.
    3. 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있으며, 이는 바람직한 설계의 핵심이다.
3. 리팩터링하면 소프트웨어를 이해하기 쉬워진다.
    1. 내 소스 코드를 컴퓨터만 사용하는게 아니다.
    2. 예컨대 몇 달이 지나 누군가 내 코드를 수정하고자 읽게 될 수 있다.
    3. 다른 프로그래머가 내 코드를 제대로 이해했다면 한 시간에 끝낼 수정을 일주일이나 걸린다면 사정이 달라진다.
    4. 다른 프로그래머가 사실 바로 나 자신일 때가 많다.
4. 리팩터링하면 버그를 쉽게 찾을 수 있다.
    1. 코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다.
    2. 프로그램의 구조를 명확하게 다듬으면 그냥 ‘이럴 것이다’라고 가정하던 점들이 분명히 드러나는데, 버그를 지나치려야 지나칠 수 없을 정도까지 명확해진다.
    3. 리팩터링은 견고한 코드를 작성하는 데 무척 효과적이다.
5. 리팩터링하면 프로그래밍 속도를 높일 수 있다.
    1. 리팩터링하면 코드 개발 속도를 높일 수 있다.
    2. 리팩터링하는 데 시간이 드니 전체 개발 속도는 떨어질까봐 걱정할 수도 있다.
    3. 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다. 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다.
    4. 리팩터링하면 기존 코드의 설계를 얼마든지 개선할 수 있으므로, 설령 프로그램 요구사항이 바뀌더라도 설계를 지속해서 개선할 수 있다.
    5. 그래서 빠른 개발이라는 숭고한 목표를 달성하려면 리팩터링이 반드시 필요하다.

## 2.4 언제 리팩터링해야 할까?

1. 비슷한 일을 세 번째 하게 되면 리팩터링 한다.
2. 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
    1. 리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다. 이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.
3. 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
    1. 코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다.
    2. 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.
    3. 코드를 분석할 때 리팩터링을 해보면, 그렇지 않았더라면 도달하지 못했을 더 깊은 수준까지 이해하게 된다.
4. 계획된 리팩터링과 수시로 하는 리팩터링
    1. 필자는 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다. 프로그래밍 과정에 자연스럽게 녹인 것이다.
    2. 리팩터링은 눈앞의 문제뿐 아니라 앞으로 할 작업에 도움을 준다.
    3. 뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 ‘수정’하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 안다.
    4. 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다.
5. 관리자에게는 뭐라고 말해야 할까?
    1. 관리자와 고객이 ‘리팩터링은 누적된 오류를 잡는 일이거나, 혹은 가치 있는 기능을 만들어내지 못하는 작업’이라고 오해하여 리팩터링이 금기어가 돼버린 조직도 있다.
    2. 기술을 모르는 상당수의 관리자와 고객은 코드베이스의 건강 상태가 생산성에 미치는 영향을 모른다. 이런 상황에 있는 이들에게는 “리팩터링한다고 말하지 말라”고 조언하겠다.
    3. 프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다. 그래서 리팩터링부터 한다.
6. 리팩터링하지 말아야 할 때
    1. 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다. 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.
    2. 리팩터링하는 것보다 처음부터 새로 작성하는게 쉬울 때도 리팩터링하지 않는다.
    3. 리팩터링할지 새로 작성할지를 잘 결정하려면 뛰어난 판단력과 경험이 뒷받침돼야 한다.

## 2.5 리팩터링 시 고려할 문제

1. 새 기능 개발 속도 저하
    1. 리팩터링의 본질은 코드 베이스를 예쁘게 꾸미는 데 있지 않다. 오로지 경제적인 이유로 하는 것이다. 리팩터링은 개발 기간을 단축하고자 하는 것이다.
    2. 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다.
2. 코드 소유권
    1. 코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다.
    2. 여전히 훌륭하게 개선할 수 있지만 제약이 따를 뿐이다.
3. 테스팅
    1. 리팩터링하기 위해서는 자가 테스트 코드를 마련해야 한다는 뜻이다.
    2. 테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와준다. 실수로 만든 버그를 빠르게 찾아서 제거할 수 있기 때문이다.
4. 레거시 코드
    1. 대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다. 이 문제의 정답은 당연히 테스트 보강이다.
    2. 레거시 코드에서 자주 보는 부분을 더 많이 리팩터링 한다.


## 2.6 리팩터링, 아키텍처, 애그니

1. 일단 코드로 작성된 뒤로는 아키텍처를 바꿀 수 없고 부주의로 인해 부패할 일만 남았다고 여기곤 했다.
2. 리팩터링은 이런 관점을 크게 바꿔놓았다. 그래서 필자는 수년 동안 운영되던 소프트웨어라도 아키텍처를 대폭 변경할 수 있었다.


## 2.8 리팩터링과 성능

1. 리팩터링하면 소프트웨어가 느려질 수도 있는 건 사실이다. 하지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다.
2. 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것이다.
3. 성능을 개선하기 위해 코드를 수정하다 보면 프로그램은 다루기 어려운 형태로 변하기 쉽고, 결국 개발이 더뎌진다.
4. 성능에 대한 흥미로운 사실은, 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다는 것이다. 그래서 코드 전체를 고르게 최적화한다면 그중 90%는 효과가 거의 없기 때문에 시간 낭비인 셈이다.
5. 만족하는 성능에 도달할 때까지 최적화 대상을 찾아서 제거하는 일을 계속한다.
6. 리팩터링은 성능 좋은 소프트웨어를 만드는 데 기여한다. 단기적으로 보면 리팩터링 단계에서는 성능이 느려질 수도 있다. 하지만 최적화 단계에서 코드를 튜닝하기 훨씬 쉬워지기 때문에 결국 더 빠른 소프트웨어를 얻게 된다.