## 2. 리팩터링 원칙

### 2.1 리팩터링 정의

<br />

리팩터링  
→ `특정한 방식`에 따라 코드를 정리하는 것.  
동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일.

성능이 변할 수는 있으나, 사용자 관점에서는 달라지는 점이 없어야 한다.
리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다.

<br />

---

<br />

### 2.2 두 개의 모자

<br />

소프트웨어 개발 목적에 따라 구분하여 작업.

- 기능 추가  
  기존 코드는 절대 건드리지 않고 `새 기능을 추가`.

- 리팩터링  
  기능 추가는 절대 하지 않고 오로지 `코드 재구성`에만 전념.

→ 작업 방식의 차이를 분명하게 인식해야 한다.

<br />

---

<br />

### 2.3 리팩터링하는 이유

<br />

`1. 소프트웨어 설계가 좋아진다.`  
아키텍처를 충분히 이해하지 못한 채, 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.  
→ 그러면 설계에 대한 파악과 유지가 어려워지고, 설계가 부패되는 속도는 더욱 빨라진다.

규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다.

바람직한 설계의 핵심  
→ 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있다.

`2. 소프트웨어를 이해하기 쉬워진다.`  
프로그램을 동작시키는 데만 신경 쓰다 보면 나중에 그 코드를 다룰 개발자를 고려 하지 ✕  
잘 작동하지만 이상적인 구조가 아닌 코드가 있다면, 리팩터링을 하자.  
→ 코드의 목적이 더 잘 드러나게 개선할 수 있다.

`3. 버그를 쉽게 찾을 수 있다.`  
리팩터링을 통해 프로그램 구조를 명확하게 다듬으면 가정하던 점들이 분명이 드러나면서, 버그가 명확해진다.

`4. 프로그래밍 속도를 높일 수 있다.`  
새로운 기능을 추가할 수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 시간 ↑  
기능을 추가하고 나면 버그가 발생하는 일이 잦고, 이를 해결하는 시간 ↑  
→ 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다.

리팩터링을 통해 기존 코드의 설계를 얼마든지 개선 가능

<br />

---

<br />

### 2.4 언제 리팩터링해야 할까?

<br />

- **준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기**  
  리팩터링 하기 가장 좋은 시점  
  → 코드베이스에 새로운 기능을 추가하기 직전

  오류를 일으키는 코드가 세 곳에 퍼져 있다면, 우선 `한 곳으로 합치는 편`이 작업하기에 훨씬 편하다.  
  또는 질의 코드에 `섞여 있는 갱신 로직을 분리`하면, 두 작업이 꼬여서 생기는 오류를 크게 줄일 수 있다.

  준비를 위한 리팩터링으로 상황을 개선  
  → 버그가 수정된 상태가 오래 지속될 가능성 ↑  
  → 같은 곳에서 다른 버그가 발생할 가능성 ↓

<br />

- **이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기**  
  코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링 해야 한다.

  `코드를 분석할 때 리팩터링을 해보면, 깊은 수준까지 이해하게 된다.`

<br />

- **쓰레기 줍기 리팩터링**  
  로직이 쓸데없이 복잡하거나, 거의 똑같은 함수 여러개를 작성해놨을 경우의 리팩터링  
  → 쓰레기 줍기 리팩터링

  수정하기 위한 시간이 걸리더라도, 조금이나마 개선해두는 것이 좋다.  
  코드를 훑어볼 때마다 조금씩 개선하다 보면 결국 문제가 해결될 것이다.

<br />

- **계획된 리팩터링과 수시로 하는 리팩터링**  
  리팩터링 시간을 일정에 따로 잡아두는 것이 아니라, 다른 일을 하는 중에 리팩터링을 처리.  
  보기 싫은 코드를 보면 리팩터링 하는 것은 당연하지만, `잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.`

  <br />

  > 뛰어난 개발자는 새 기능을 추가하기 쉽도록 `코드를 '수정'하는 것이 그 기능을 가장 빠르게 추가하는 길`일 수 있음을 안다.

  <br />

  정기적인 리팩터링  
  → 이를 통해 몇 달동안 효과를 누릴 수도 있지만, `어떤 문제는 팀원 여럿이 달려들어야 할 정도로 곪아갈 수도 있다.`  
  → 따라서 계획된 리팩터링을 최소한으로 줄여야 한다.

<br />

- **오래 걸리는 리팩터링**
  대규모의 리팩터링에 대해 매달리기 보다는 주어진 문제를 몇 주에 걸쳐 조금씩 해결하는 편이 효과적.  
  → 일부를 변경하더라도 `리팩터링은 코드를 깨트리지 않음`으로 모든 기능이 항상 올바르게 동작한다.

<br />

- **코드 리뷰에 리팩터링 활용하기**  
  코드 리뷰를 하면서 새로운 아이디어가 떠오르면 리팩터링하여 쉽게 구현해넣을 수 있는지 살펴본 후, 쉽다면 실제로 리팩터링을 한다.  
  → 이를 반복하다보면 내가 떠올린 아이디어가 실제로 적용했을 때의 모습을 더 명확하게 볼 수 있다.  
  → 리팩터링해보지 않고는 절대 떠올릴 수 없던 아이디어가 떠오르기도 한다.

  코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움이 된다.  
  → 개선안들 중, 대부분을 즉시 구현해볼 수 있기 떄문.

<br />

- **관리자에게는 뭐라도 말할까?**  
  프로 개발자의 역할은 효과적인 소프트웨어를 최대한 빨리 만드는 것.  
  → 리팩터링하면 소프트웨어를 빠르게 만드는 데 효과적.

  `프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다.`

<br />

- **리팩터링하지 말아야 할 때**
  - 외부 api 다루듯 호출해서 쓰는 코드.
  - 리팩터링을 하는 것보다 처음부터 새로 작성하는 게 쉬울 때.

<br />

---

<br />

### 2.5 리팩터링 시 고려할 문제

<br />

- **새 기능 개발 속도 저하**
  <br />

  > 리팩터링의 궁극적인 목적은 `개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것`이다.

  <br />

  코드베이스가 건강하면 기존 코드를 새로운 방식으로 조합하기 쉬워서 복잡한 새 기능을 더 빨리 추가할 수 있다.

  리팩터링의 본질  
  → 코드 베이스를 이쁘게 꾸미는 것이 아니라, 오로지 개발 기간을 단축하고자 하는 것.  
  → 기능 추가 시간을 줄이고, 버그 수정 시간을 줄이는 것.

<br />

- **코드 소유권**  
  코드 소유권이 나눠져 있으면 리팩터링에 방해가 된다.  
  → 클라이언트에 영향을 주지 않고서는 원하는 형태로 변경할 수 없기 때문.

  코드 소유권을 개인이 아닌 '팀'에 두는 것.  
  → 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 한다.

<br />

- **브랜치**  
  팀원마다 각자의 브랜치를 맡아서 작업하다가, 결과물이 어느 정도 쌓이면 마스터 브랜치에 통합.  
  → 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다.

  기능별 브랜치의 통합 주기를 매우 짧은 단위로 관리  
  → 지속적 통합(Continuous Integration, CI) 또는 트렁크 기반 개발(Trunk-Based Development, TBD)  
  → 모든 팀원이 하루에 최소 한 번은 마스터와 통합하면, 브랜치들 사이에서 차이가 크게 벌어지지 않아 머지의 복잡도를 상당히 ↓

  리팩터링을 하다 보면 자잘하게 수정하는 부분이 많아, 머지 과정에서 의미 충돌이 생기기 쉽다.  
  → CI를 통해 이를 어느정도 해소할 수 있다.

<br />

- **테스팅**  
  오류를 재빨리 잡으려면, 코드의 다양한 측면을 검사하는 `테스트 스위트`가 필요.  
  → 리팩터링하기 위해서는 자가 테스트 코드를 마련해야 한다.

  테스트가 실패한다면 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴볼 수 있다.  
  → 테스트 주기가 짧다면 몇 줄만 비교하면 되기 때문에 버그를 보다 쉽게 찾을 수 있다.

  리팩터링 과정에서 버그가 생길 위험이 아주 크다는 불안감을 해소할 수 있다.

<br />

- **레거시 코드**  
  레거시 시스템을 파악할 때, 리팩터링이 도움이 되지만 테스트가 없기때문에 명료하게 리팩터링 하기 어렵다.  
  → 테스트 보강을 통해 문제를 해결.

  프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트.  
  → 이러한 틈새를 만들 때, 리팩터링을 활용

  서로 관련된 부분끼리 나눠서 하나씩 공략하는 것.  
  → 규모가 크다면 자주 보는 부분을 더 많이 리팩터링 한다.

<br />

- **데이터베이스**  
  커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성.  
  → 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트를 통해 처리.

  전체 변경 과정을 작고 독립된 단계들로 쪼개는 것.

  데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리즈.  
  → 프로덕션 환경에서 문제가 생겼을 때 되돌리기 쉽다.

<br />

---

<br />

### 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

<br />

리팩터링이 아키텍처에 미치는 실질적인 효과  
→ 요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해준다.

어느 부분에 유연성이 필요하고 어떻게 해야 그 변화에 대응할 수 있을지 `추측하지 않고,`  
`현재까지 파악한 요구사항만을 해결하는 소프웨어를 구축`한다.

진행하면서 사용자의 요구사항을 더 잘 이해하게 되면 아키텍처도 그에 맞게 리팩터링 한다.  
그 과정에서 소프트웨어의 복잡도에 지장을 주지 않는 메커니즘은 마음껏 추가하지만,  
복잡도를 높일 수 있는 `유연성 메커니즘은 반드시 검증을 거친 후에 추가`한다.  
→ 간결한 설게(simple design), 점진적 설계(incremental design), YAGNI(you aren't going to need it)

나중에 문제를 더 깊이 이해하게 됐을 때 처리하는 쪽이 훨씬 낫다.

<br />

---

<br />

### 2.7 리팩터링과 소프트웨어 개발 프로세스

<br />

> 애자일을 제대로 적용하려면 리팩터링에 대한 팀의 역량과 열정이 뒷받침되어 `프로세스 전반에 리팩터링이 자연스럽게 스며들도록 해야 한다.`

<br />

자가 테스트 코드 + 리팩터링  
→ 테스트 주도 개발(Test-Driven Development, TDD)

리팩터링의 첫번째 토대, 자가 테스트 코드  
→ 프로그래밍 도중 발생한 `오류를 확실히 걸러내는 테스트를 자동으로 수행`할 수 있어야 한다.

팀으로 개발하면서 리팩터링을 하려면 각 팀원이 다른 사람의 작업을 방해하지 않으면서 언제든지 리팩터링할 수 있어야 한다.  
→ 지속적 통함(CI)를 통해 팀원 각자가 수행한 리팩터링 결과를 빠르게 동료와 공유할 수 있다.  
→ 자가 테스트 코드도 지속적 통합의 핵심 요소

<br />

> 따라서 자가 테스트 코드, 지속적 통합, 리팩터링이라는 세 가지 기법은 서로 강력한 상승효과를 발휘한다.

<br />

세 가지 실천법을 잘 조화시키면 요구사항 변화에 재빠르게 대응하고 안정적인 선순환 구조를 코드베이스에 심을 수 있다.

지속적 배포를 통해 소프트웨어를 언제든 릴리스할 수 있는 상태로 유지  
→ 위험요소를 줄이고, 기술적인 제약보다는 비즈니스 요구에 맞춰 릴리스 일정에 대해 계획 가능  
→ 아이디어를 프로덕션 코드로 반영하는 시간을 ↓, 고객에게 더 나은 서비스를 제공 ○

<br />

---

<br />

### 2.8 리팩터링과 성능

<br />

리팩터링  
→ 소프트웨어가 느려질 수도 있다.  
→ 동시에 성능을 튜닝하기 더 쉬워진다.

소프트웨어를 빠르게 만드는 비결  
→ 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것.

<br />

**빠른 소프트웨어를 작성하는 방법 세 가지**

1. 예산 분배 방식  
   → 설계를 여러 컴포넌트로 나눠서 컴포넌트마다 자원(시간과 공간) 예산을 할당.  
   → 컴포넌트는 주어진 예산을 초과할 수 ✕  
   → 엄격한 시간 엄수 강조

2. 끊임없이 관심을 기울이는 것  
   → 성능 개선을 위해 코드를 수정하다 보면 프로그램은 다루기 어려운 형태로 변하기 쉽고, 결국 개발이 더뎌진다.  
   → 성능을 개선하기 위한 최적화가 퍼지지만 컴파일과 런타임과 하드웨어의 동작을 제대로 이해하지 못한 채 작성 된다.

3. 의도적으로 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는데 집중  
   → 성능 최적화 단계에 돌입하기 전까지는 성능에 신경 ✕  
   → 성능 최적화 단계가 되면 구체적인 절차에 따라 프로그램을 튜닝

   프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다.  
   → 해당 부분들을 리팩터링할 떄처럼 작은 단계로 나눠서 개선
   → 각 단계마다 컴파일과 테스트
   → 성능이 개선되지 않았다면 수정 내용 롤백
   → 사용자가 만족하는 성능에 도달할 때까지 최적화 대상을 찾아 제거

<br />

**프로그램을 잘 리팩터링 했을 때, 이점**

1. 성능 튜닝에 투입할 시간을 벌 수 있다.
2. 리팩터링이 잘 되어 있는 프로그램은 더 세밀하게 분석할 수 있다.

<br />

> 리팩터링은 성능 좋은 소프트웨어를 만드는 데 기여한다. 단기적으로 보면 리팩터링 단계에서는 성능이 느려질 수도 있다.
> 하지만 최적화 단계에서 코드를 튜닝하기 월씬 쉬워지기 때문에 결국 더 빠른 소프트웨어를 얻게 된다.

<br />

---

<br />

### 2.9 리팩터링의 유래

<br />

리팩터링  
→ 소프트웨어 개발 프로세스 전반의 핵심 요소

스몰토크  
→ 컴파일 - 링크 - 실행 주기가 상당히 짧아서 마지막으로 컴파일한 시점을 안다면 빠른 수정 작업 가능  
→ 객체 지향 언어라서 인터페이스만 잘 정의해두면 내부 수정이 미치는 영향을 ↓  
→ 생산성을 높이기 위해 리팩터링의 역할 ↑

리팩터링 도구 아이디어를 발전시켜서 스몰토크 환경을 위한 최초의 리팩터링 도구인 `리팩터링 브라우저`를 개발

<br />

---

<br />

### 2.10 리팩터링 자동화

<br />
 
리팩터링을 자동화하는 가장 어설픈 방법  
→ 소스 코드의 텍스트를 직접 조작 하는 것  
→ 허점이 많기 때문에 테스트 하기 전에는 결과를 신뢰해서는 안된다.

자동 리팩터링을 제대로 구현하려면, 코드를 텍스트가 아닌, `구문 트리로 해석`해서 다뤄야 한다.  
→ 구문 트리를 조작하는 방식이 코드의 원래 의미를 보존하는데 훨씬 더 유리  
→ 변경된 구문 트리를 다시 텍스트로 바꿔 표현해야 해서, 리팩터링 기능을 제대로 구현하기 어렵다.

IDE가 제공하는 리팩터링 기능이 갈력하기 떄문에` IDE를 사용하는 편이 프로그래밍 효율 면에서 훨씬 유리`하다.

간혹 완성도가 낮은 리팩터링 도구들은 자바의 리플렉션 기능을 써서 메서드를 호출하는 부분을 제대로 처리하지 못한다.  
→ 그래서 중간에 꼬인 부분이 없는지 테스트로 확인하는 것이 바람직하다.
→ 자동 리펙터링과 수동 리펙터링을 함께 사용

<br />
