
# Chapter02 리팩터링 원칙
<br/>

## 2.1 리팩터링의 정의

<b>리팩터링 : [명사]</b> : 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
<br/>
<b>리팩터링(하다) [동사]</b> : 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성한다. 

리팩터링은 성능 최적화와 비슷하다. 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다. 단지 목적이 다를 뿐이다.<br/>
리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다. 반면 성능 최적화는 오로지 속도 개선에만 신경 쓴다.


## 2.2 두 개의 모자

>켄트 백은 소프트웨어를 개발 할 때 두 개의 모자에 비유했다.
기존 코드를 절대 건드리지 않고 새 기능을 추가하는 '기능 추가' 모자와, 기능 추가는 절대 하지 않고 오로지 코드 재구성에만 전념하는 '리팩터링' 모자이다. 전자는 테스트를 추가해서 통과하는지 확인하는 방식으로 진척도를 측정하고 후자는 앞 과정에서 놓친 테스트 케이스를 발견하지 않는 한 테스트로 새로 만들지 않는다.
<br/>


*  인상깊은 구절 <br/>
  새 기능을 추가하다 보면 코드 구조를 바꿔야 작업하기 훨씬 쉽겠다는 생각이 들기도 하는데, 그러면 잠시 모자를 바꿔 쓰고 리팩터링한다. 코드 구조가 어느 정도 개선되면 다시 모자를 바꿔 쓰고 기능 추가를 이어간다. 
  코드 구조가 어느 정도 개선되면 다시 모자를 바꿔 쓰고 기능 추가를 이어간다. 추가한 기능이 제대로 작동하는지까지 확인했다면 작성한 코드를 살펴본다. 코드가 이해하기 어렵게 짜였다면 다시 모자를 바꿔 쓰고 리팩터링한다. 전체 작업 시간이 10분 정도로 짧다 해도, 항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야 한다.

<br/>

## 2.3 리팩터링하는 이유

* 인상깊은 구절<br/>
  중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있으며, 이는 바람직한 설계의 핵심이다.

<b>리팩터링하면 소프트웨어 설계가 좋아진다.</b>
* 코드를 보면 알 수 있는 것들은 의도적으로 기억하지 않는다. 기억할 필요가 있는 것들은 최대한 코드에 담으려고 한다.

<b>리팩터링하면 버그를 쉽게 찾을 수 있다.</b>
* 리팩터링을 하면 프로그램을 다듬으며 구조가 명확해지고 '이럴 것이다' 가정하던 점들이 분명히 드러나서 버그를 찾기 쉬워진다.
> 켄트 백 "난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요."

<b>리팩터링하면 프로그래밍 속도를 높일 수 있다.</b>
* 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다. 이것을 저자는 설계 지구력 가설이라고 부른다.
<br/>

## 2.4 언제 리팩터링해야 할까?
#### 3의 법칙
>돈 로버츠(Don Roberts)가 제시한 가이드 
>1. 처음에는 그냥 한다.
>2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.
>3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.
야구를 좋아하는 사람을 '스트라이크 세 번이면 리팩터링하다(삼진 리팩터링)'로 기억하자.
<br/>

#### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.

#### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지가 없는지 찾아본다. 조건부 로직의 구조가 이상하지 않은지, 함수 이름을 잘못 정해서 실제로 하는 일을 파악하는데 시간이 오래 걸리지 않는지 살펴본다.
>커닝햄이 말하길, 리팩터링하면 머리로 이해한 것을 코드에 옮겨 담을 수 있다.
그런 다음 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인할 수 있다.

코드를 분석할 떄 리팩터링을 해보면, 그렇지 않았더라면 도달하지 못했을 깊은 수준까지 이해하게 된다.

#### 쓰레기 줍기 리팩터링
간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다. 이것이 이해를 위한 리팩터링의 변형인 쓰레기 줍기 리팩터링이다.

#### 계획된 리팩터링과 수시로 하는 리팩터링
리팩터링 일정을 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다. 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다. 
리팩터링은 실수롤 바로잡거나 보기 싫은 코드를 정리하는 작업이라고 오해하기 쉽다. 
기능을 추가하기 위한 최고의 방법은 기능을 추가하기 쉽도록 수정하는 것이다.
소프트웨어 개발은 끝이 없는 작업으로 잘 작성된 코드도 수많은 리팩터링을 거쳐야 한다.
>무언가 수정하려 할 때 수정하기 쉽게 정돈하고 그런 다음 쉽게 수정하자

계획된 리팩터링을 무조건 나쁘지 않지만 리팩터링에 몇 달이 걸릴정도로 리소스를 소요하게 될 수 있으므로 최소한으로 줄이는 것이 좋다.

* 인상깊은 구절<br/>
버전 관리 시스템에서 리팩터링 커밋과 기능 추가 커밋을 분리해야 한다는 조언을들은 적이 있다. 이렇게 할 때의 큰 장점은 두 가지 활동을 구분해서 별개로 검토하고 승인할 수 있다는 것이다. 하지만 리팩터링은 기능 추가와 밀접하게 엮인 경우가 너무나 많기 때문에 굳이 나누는 것은 시간 낭비일 수 있다. 또한 해당 리팩터링을 하게 된 맥락 정보가 사라져서 왜 그렇게 수정했는지 이해하기 어려워진다.

#### 오래 걸리는 리팩터링 (추상화로 갈아타기)
리팩터링에 오래 매달리는 것보다, 리팩토링해야 할 코드와 관련한 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 방식이 좋다.
라이브러리를 교체할 때는 기존 것과 새 것을 모두 포용하는 추상 인터페이스부터 마련한다. 기존 코드가 이 추상 인터페이스를 호출하도록 만들고 하면 라이브러리를 훨씬 쉽게 교체할 수 있다.
이 전략을 추상화로 갈아타기라고 한다.

#### 코드 리뷰에 리팩터링 활용하기
리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움된다. 개선안들을 제시하는 데서 그치지 않고, 그중 상당수를 즉시 구현해볼 수 있기 때문이다. 
흔히 쓰는 풀 요청 모델(코드 작성자 없이 검토하는 방식)에서는 효과적이지 않고 작성자가 맥락을 설명해줄 수 있고 작성자로 리뷰어의 변경 의도를 제대로 이해할 수 있는 참석자가 참석하는 방식이 좋다. 
\* 저자가 경함한 가장 좋은 방법은 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링하는 것이다. 이렇게 하면 자연스럽게 (프로그래밍 과저 안에 지속적인 코드 리뷰가 녹아 있는) 짝 프로그래밍이 된다.

#### 관리장에게는 뭐라고 말해야 할까?

>리팩토링이 아닌 어설픈 재구성이 되지 않도록 주의한다.

기술을 모르는 상당수의 관리자와 고객은 코드베이스의 건강 상태가 생산성에 미치는 영향을 모른다. 
저자의 경험상 리팩터링하면 소프트웨어를 빠르게 만드는 데 아주 효과적이다. 
프로 개발자의 역할은 효과적인 소프트웨어를 최대한 빨리 만드는 것이다. 그러므로 "리팩터링한다고 말하지 말라" 고 조언한다.

#### 리팩터링하지 말아야 할 떄

1. 외부 API 다루듯 호출해서 쓰는 코드
2. 처음부터 새로 작성하는게 쉬울 때(직접 리팩터링 하기 전에 어느 쪽이 쉬운지 알 수 없을 때. 뛰어난 판단력과 경험이 뒷받침돼야 한다.)

<br/>

## 2.5 리팩터링 시 고려할 문제
>리팩터링의 궁극적인 목표는 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

#### 새 기능 개발 속도 저하
>사람들이 빠지기 가장 위험한 오류는 리팩터링을 '클린 코드'나 '바람직한 엔지니어링 습관'처럼 도덕적인 이유로 정당화하는 것이다. 리팩터링의 본질은 코드베이스를 예쁘게 꾸미는 데 있지 않다. 오로지 경제적인 이유로 하는 것이다. 리팩터링은 개발 기간을 단축하고자 하는 것이다.
기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다.


#### 코드 소유권
리팩터링하다 보면 모듈의 내부뿐 아니라 시스템의 다른 부분과 연동하는 방식에도 영향을 주는 경우가 많다. 함수 이름을 바꾸고 싶고 그 함수를 호출하는 곳을 모두 찾을 수 있다면, 함수 선언 바꾸기로 선언 자체와 호출하는 곳 모두를 한 번에 바꿀 수 있다.
하지만 함소룰 호출하는 코드의 소유자가 다른 팀이라서 나에게 쓰기 권한이 없다면, 
>함수 이름을 변경할 때는 함수 이름 바꾸기를 적용하는 한 편, 기존 함수도 그대로 유지하되 함수 본문에서 새 함수를 호출하도록 수정한다.

코드 소유권을 엄격히 제한하는 방식과 완전히 풀어서 변경을 통제하기 어려운 방식을 절충하기 위해 오픈소스 개발 모델을 사용하여 다른 사람이 작업한 코드를 수정할 때는 새 브랜치를 따서 수정 후 커밋하고 관리하는 쪽에서 승인하면 수정하는 방식을 사용할 수 있다.

#### 브랜치
독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다. 이 고통을 줄이고자 많은 이들이 리베이스하거나 머지하는데 여러 기능 브랜치에서 동시에 개발이 진행될 때는 이런 식으로 해결할 수 없다.
>마스터를 브랜치로 '머지'하는 작업은 단방향이다. 브랜치만 바뀌고 마스터는 그대로다. 반면 '통합'은 마스터를 개인 브랜치로 가져와서(pull)해서 작업한 결과를 마시 마스터에 올리는(push) 양방향 처리를 뜻한다. 그래서 마스터와 브랜치 모두 변경된다. 누군가 개인 브랜치에서 작업한 내용을 마스터에 통합하기 전까지는 다른 사람이 그 내용을 볼 수 없다.
통합한 뒤에는 마스터에서 달라진 내용을 내 브랜치에서 머지해야 하는데, 그러려면 상당한 노력이 들 수 있다. (하략)
>브랜치의 통합 주기를 단위로 짧게 잘라서 관리하는 방식을 지속적 통합(Continuous Integration, CI), 또는 트렁크 기반 개발(Trunk-Based Development, TBD)이라 한다.

CI는 모든 팀원이 하루에 최소 한 번은 마스터와 통합한다. 이렇게 하면 다른 브랜치들과의 차이가 크게 벌어지는 브랜치가 없어져서 머지의 복잡도를 상당히 낮출 수 있다. 하지만 마스터를 건강하게 뮤지하고, 거대한 기능을 잘게 쪼재는 법을 배우고, 각 기능을 끌 수 있는 기능 토글(기능 플래그)을 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야 한다.
리팩토링을 하다 보면 코드베이스 전반에 걸쳐 자잘하게 수정하는 부분이 많을 때가 있다.
프로그램 전체에서 자주 사용하는 함수의 이름을 바꾸는 경우가 이러한 예다. 이렇게 되면 머지 과정에서 의미 충돌이 생기기 쉽다. 특히 기능별 브랜치 방식에서는 리팩터링을 도저히 진행할 수 없을 정도로 심각한 머지 문제가 발생하기 쉽다. 켄트 백이 CI와 리팩터링을 합쳐서 <b>익스트림 프로그래밍(XP)</b>을 만든 이유도 바로 두 기법의 궁합이 잘 맞기 때문이다.
>이따금 커밋이 들어오는 오픈 소스 프로젝트라면 기능별 브랜치 방식이 적합할 수 있다. 하지만 풀타임 개발팀이라면 브랜치가 가져오는 리팩터링 부담이 크다. CI를 완벽히 적용하지는 못하더라도 통합 주기만큼은 최대한 짧게 잡아야 한다.

#### 테스팅
리팩터링을 위해서 자가 테스트 코드를 마련해야 한다.(스스로 성공/실패를 판단하는 테스트)
테스트가 실패한다면 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴볼 수 있다.
테스트 주기가 짧다면 단 몇 줄만 비교하면 되며, 문제를 일으킨 부분이 그 몇 줄 안에 있기 때문에 버그를 훨씬 쉽게 찾을 수 있다.
>자동 리팩터링 기능을 사용해도 효과가 좋다. 또는 검증된 몇 가지 리팩터링 기법만 조합해서 사용하는 흐름도 있다. (*제이 바주지의 글에서 C++에서 메서드를 안전하게 추출하는 방법을 설명하고 있다.)

자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용할 수 있어서 자연스럽게 CI와도 밀접하게 연관된다. CI에 통합된 테스트는 XP의 권장사항이자 지속적 배포(CD)의 핵심이기도 한다.


#### 레거시 코드
>프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다
\* 레거시 코드 활용 전략(에이콘, 2018)

* 서로 관련된 부분끼리 나누어서 하나씩 공략한다. 코드의 한 부분을 훑고 넘어갈 때마다 예전보다 조금이라도 개선하려고 노력한다.
* 레거시 시스템의 규모가 크다면 자주 보는 부분을 더 많이 리팩터링한다. 코드를 훑게 되는 횟수가 많다는 말은 그 부분을 이해하기 쉽게 개선했을 때 얻는 효과도 그만큼 크다는 뜻이다.

#### 데이터베이스
>커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합한다.
*프라모드 사달게
진화형 데이터베이스 설계 / 데이터베이스 리팩터링 
>
>필드의 이름을 변경하는 경우, (함수 선언 바꾸기) 이 변환을 수행하는 코드를 간단히 작성한 다음, 선언된 데이터 구조나 접근 루틴을 변경하는 코드와 함께 버전 관리 시스템에 저장한다. 그러 다음 데이터베이스를 다른 버전으로 이전할 때마다 현재 버전에서 원하는 버전 사이에 있는 모든 마이그레이션 스크립트를 실행한다.

데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다. 이렇게 하면 프로덕션 환경에서 문제가 생겼을 때 변경을 되돌리기 쉽다. 필드 이름을 바꿀 때 첫 번째 커밋에서는 새로운 데이터베이스 필드를 추가만 하고 사용하지는 않는다.
그런 다음 기존 필드와 새 필드를 동시에 업데이트하도록 설정한다. 그 다음에는 데이터베이스를 읽는 클라이언트들을 새 필드를 사용하는 버전으로 조금씩 교체한다. 이 과정에서 발생하는 버그도 해결하면서 클라이언트 교체 작업을 모두 끝냈다면, 더는 필요가 없어진 예전 필드를 삭제한다. 이렇게 데이터베이스를 변경하는 방식은 <b>병렬 수정(또는 팽창- 수축)</b>의 일반적인 예다.
<br/>

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)
리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해준다는 데 있다.
코딩 전에 아키텍터를 확정징으려 할 때의 대표적ㅇ인 문제는 소프트웨어 요구사항을 사전에 모두 파악해야 한다는 것이다. 하지막 막상 해보면 실현할 수 없는 목표일 때가 많다. <b>우리는 소프트웨어를 실제로 사용해보고 업무에 미치는 영향을 직접 확인하고 나서야 정말로 원하는 바를 알게 되는 경우가 허다하다.</b>

>소프트웨어 변경사항에 유연하게 대처하려면 유연성 메커니즘을 소프트웨어에 심어둔다.
가령 함수를 정의하다 보면 범용적으로 사용할 수 있겠다는 생각이 들 때가 있다. 다양한 예상 시나리오에 대응하기 위한 매개변수드을 추가하는데, 이런 매개변수가 <b>유연성 메커니즘</b>이다. 
단, 변화를 추측하지 않고 현재 요구사항까지만 만들어둔다. 진행하면서 사용자 요구사항을 더 잘 이해하게 되면 리팩터링을 통해 메커니즘을 추가하고, 복잡도를 높일 수 있는 유연성 메커니즘은 반드시 검증을 거친 후에 추가한다.
호출하는 측에서 항상 같은 값을 넘기는 매개변수는 매개변수 목록에 넣지 않는다. 그러다 매개변수를 추가해야 할 시점이 오면 간단한 리팩터링 기법인 <b>함수 매개변수화하기</b>로 해결한다.
예상되는 변경을 미리 반영하는 리팩터링을 미루면 나중에 얼마나 어려워질지를 가늠해보면 판단에 도움이 된다. 어려워질 것 같다는 확신이 들면 유연성 메커니즘을 미리 추가한다.
이런 식으로 설계하는 방식을 간결한 설계, 점진적 설계, YAGNI(에그니, yo aren't going to need it,필요 없을 거다) 등으로 부른다. (이것이 아키텍처를 고려하지 말라는 뜻이 아니다.)

나중에 문제를 더 깊이 이해하게 됐을 때 처리하는 경향은 진화형 아키텍처 원칙이 발전하는 계기가 됐다.(진화형 아키텍처를 아키텍처 관련 결정을 시간을 두고 반복해 내릴 수 있다는 장점을 활용하는 패턴과 실천법을 추구한다.)

\* YAGNI는 익스트림 프로그래밍의 원칙 중 하나로 당장에 필요한 기능만으로 최대한 간결하게 만들라는 뜻이다. 실제로도, 앞으로 필요할 것 같아서 미리 구현해둔 기능 상당수가 결국 전혀 쓰이지 않거나, 미래의 요구사항을 제대로 반영하지 못하여 오히려 수정하기 더 어려워지는 경우가 많다.
\* 진화형 아키텍처는 클린 아키텍처에서 얘기하는 "컴포넌트 의존성 구조는 시스템의 논리적 설계에 발맞춰 성장하며 또 진화해야 한다"는 주장도 같은 맥락으로 이해할 수 있을 것이다.
<br/>

## 2.7 리팩터링과 소프트웨어 개발 프로세스
>2.5절을 읽었다면 팀이 따르는 실천법에 따라 리팩터링의 효과가 크게 달라진다는 사실을 발견했을 것이다. 리팩터링이 퍼지기 시작한 것도 익스트림 프로그래밍(xp)에 도입됐기 때문이었다. XP의 두드러진 특징은 지속적 통합, 자가 테스트 코드, 리팩터링 등의 개성이 강하면서 상호 의존적인 기법들을 하나로 묶은 프로레스라는 점이다. 참고로 자가 테스트 코드와 리팩터링을 묶어서 <b>테스트 주도 개발(TDD)</b>이라 한다.

최초의 애자일 소프트웨어 방법론 중 하나로 등장한 XP는 그 후 수년에 걸쳐 애자일의 부흥을 이끌었다.

리팩터링의 첫 번째 토대는 자가 테스트 코드다. 다시 말해 프로그래밍 도중 발생한 오류를 확실히 걸러내는 테스트를 자동으로 수행할 수 있어야 한다. 테스트는 리팩터링에 굉장히 중요한 토대이다.

<b>팀으로 개발하면서 리팩터링을 하려면 각 팀원이 다른 사람의 작업을 방해하지 않으면서 언제든지 리팩터링할 수 있어야 한다.</b>

* 자가 테스트 코드
* 지속적 통합(CI)
* 리팩터링

이라는 세 기법은 서로 강력한 상승효과를 발휘한다.

<br/>

## 2.8 리팩터링과 성능
> 성능에 대한 흥미로운 사실은, 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다는 것이다. 그래서 코드 전체를 고르게 최적화한다면 그 중 90%는 효과가 거의 없기 때문에 시간 낭빙인 셈이다. 속도를 높이기 위해 투자한 시간(다른 관점에서 보자면 코드를 덜 명료하게 바꾸느라 투자한 시간)을 모두 날리는 행위다.

* 빠른 소프트웨어를 작성하는 세 가지 방법
  1. 시간 예산 분배
   * 리얼 하드타음 시스템에서 많이 사용하는 방식으로 설계를 ㅇ여러 컴포넌트로 나눠서 컴포넌트마다 자원(시간과 공간) 예산을 할당한다. 컴포넌트는 할당된 장원 예산을 초과할 수 없다. 단, 주어진 자원을 서로 주고받는 메커니즘을 제공할 수는 있다.
  2. 끊임없는 관심을 기울임
    * 흔히 사용하는 방식이지만 실제 효과는 변변치 않다.
  3. 의도적으로 성능 최적화에 돌입하기 전까지 성능에 신경쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다. 성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램을 튜닝한다.
   * 먼저 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다. 전체를 고르게 최적화할 때 그 부분들을 개선한다. 리팩터링할 때처럼 최적화를 위한 수정도 작은 단계로 나눠서 진행한다. 각 단계마다 컴파일과 테스트를 거치고 프로파일러를 다시 실행해본다. 사용자가 만족하는 성능에 도달할 때까지 최적화 대상을 찾아서 제거하는 일을 계속한다.
<br/>

## 2.9 리팩터링의 유래
> 리팩터링이란 용어의 정확한 유래는 없다.

리팩터링의 중요함을 깨달은 선구자들인 워드 커닝햄과 켄트 벡은 1980년대부터 스몰토크를 활용해 개발해왔다.
<br/>

## 2.10 리팩터링 자동화
>리팩터링을 자동화하는 가장 어설픈 방법은 소스 코드의 텍스트를 직접 조작하는 것이다.
'찾아 바꾸기' 기능으로 이름을 변경하거나 "변수 추출하기"를 위해 간단히 코드를 재구성하는 식이다. 이 방식은 허점이 많기 때문에 테스트해보기 전에는 결과를 신뢰해서는 안 된다.

자동 리팩터링을 제대로 구현하려면 코드를 텍스트 상태가 아닌, 구문 트리로 해석해서 다뤄야 한다. 구문 트리를 조작하는 방식이 코드의 원래 의미를 보존하는 데 훨씬 유리하기 때문이다.
IDE는 리팩터링뿐 아니라 코드 탐색과 린팅(정적 분석)을 비롯한 다양한 기능을 구현하는 데 구문 트리를 활용한다. 

<자동화를 도와주는 도구들>
* 이맥스
* 이텔리제이
* 언어 서버

<br/>

## 2.11 더 알고 싶다면

<리팩터링 연습에 주력한 책>
* 리팩터링 워크북(인사이트, 2006) 
  * 저자 : 윌리엄 웨이크
  * 리팩터링을 충분히 연습할 수 있도록 다양한 예제를 제공하는 책이다.
* 패턴을 이용한 리팩터링(인사이트, 2011)
  * 저자 : 조슈아 케리에프스카
  * 소프트웨어 패턴 분야에 지대한 영향을 준 디자인 패턴 책에서 가장 핵심적인 패턴을 골라, 코드를 그 패턴대로 재구성하기 위해 리팩터링하는 방법을 다룬다.
* 리팩터링 데이터베이스
  * 저자 : 스캇 엠블러, 프라모드 사달게
* 리팩터링 HTML
  * 저자 : 엘리엇 러스티 해롤드
* 레거시 코드 활용 전략
  * 저자 : 마이클 페더스
  * 테스트 커버리지가 낮은 오래된 코드베이스를 리팩터링하는 방법을 다루고 있다.

---

[최신 자료](https://github.com/WegraLee/Refactoring)
<br/>
[리팩터링 웹사이트](https://refactoring.com/)

##
<br/>

>챕터2에서는 전반적으로 리팩터링의 개념과 목적, 리팩터링하는 방법에 대해 설명하고 있다.<br/>
>중복 코드처럼 몇 장에 걸쳐 반복적으로 설명하고 있는 내용도 있는데, 리팩터링의 실제 목적이다.<br/>
><b>리팩터링의 궁극적인 목적은 경제 가치를 창출하는 것이다.</b><br/>
>리팩터링의 목적이 단순히 "보기좋은 코드"는 아니라는 것이다.<br/>
>나 또한 여태까지 리팩터링을 단순히 "보기 좋은", "유지 보수를 잘하기 위한" 도구로 생각하고 있었다.<br/>
>1판이 나온지도 10년이 됐는데 아직도 잘못 알고 있는 사람이 있으니 중요하게 생각하고 <br/>
>반복해서 설명할만 하다는 생각이 들었다.<br/>
> 챕터1에서는 리팩터링을 하면서 성능은 신경쓰지 말라고 했다. 챕터2에서는 그 이유를 설명한다.<br/>
>사실 개발하면서 좋은 코드도 중요하지만 성능 또한 중요한 부분 중 하나로<br/>
>체감을 많이 느끼는 부분이기 때문에 성능을 고려하지 말라는 말은 의문이 있었다. <br/>
>챕터2에서는 리팩터링을 통해 성능을 개선할 수 있는 방법을 알려준다.<br/>
>성능은 생략한 리팩터링한 코드를 짜고 컴파일과 테스트, 프로파일러 실행 과정을 거쳐서 <br/>
>문제 지점을 찾아내고 최적화 될 때까지 반복하는 것이다.<br/>
>이렇게 하면 오히려 나중에 문제가 생길 부분을 미리 파악할 수 있고 리팩터링으로 <br/>
>좋은 코드를 만들 수도 있다.<br/>
>아키텍처를 리팩터링하는 방법에 대해서도 설명하고 있는데 미리 설계를 하지 말고 <br/>
>추후 수정사항이 생겼을 경우, 점진적으로 고쳐나가는 유연성 매커니즘으로 해결한다.<br/>
>이러한 방식을 간결한 설계, 점진적 설계, 에그니 등으로 부른다.<br/>
>그 외에 코드 소유권 해결 방법과 개발 프로세스 적용하는 방법 등을 설명하고 있다.<br/>
>저자의 경험이 녹아든 노하우는 리팩터링을 적용하려고 하는 팀에 많은 도움이 될 것 같았다.<br/>
>
>챕터2를 읽고 두루뭉술하게 느끼고 있었던 리팩터링이란 무엇인가? 에 대한 답이 분명해지고<br/> 
>잘못 알고 있었던 개념들도 바로잡을 수 있었다.<br/>
>단순히 "보기좋은 코드"를 위해 리팩터링을 해야 한다고 생각했을 땐<br/>
>리팩터링을 개발자가 적용해야만 하는 이유를 설명하기 힘들었지만 이제는<br/>
>왜 필요한지, 어떤 효과를 줄 수 있는지도 알게 되었다.<br/>
>하지만 중간에 저자가 말했듯이 리팩터링을 잘 수행하려면 충분한 연습과 실력을 키우는 것이 중요하고<br/>
>그렇지 않다면 어설픈 재구성이 될 뿐이라는 점을 유의해야 할 것 같다. 





